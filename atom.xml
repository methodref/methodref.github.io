<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Methodref的博客</title>
  
  <subtitle>Methodref</subtitle>
  <link href="https://blog.methodref.top/atom.xml" rel="self"/>
  
  <link href="https://blog.methodref.top/"/>
  <updated>2021-06-29T22:50:35.000Z</updated>
  <id>https://blog.methodref.top/</id>
  
  <author>
    <name>Methodref</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>处理个人事务工作流</title>
    <link href="https://blog.methodref.top/2020/10/22/9.%E5%A4%84%E7%90%86%E4%B8%AA%E4%BA%BA%E4%BA%8B%E5%8A%A1%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    <id>https://blog.methodref.top/2020/10/22/9.%E5%A4%84%E7%90%86%E4%B8%AA%E4%BA%BA%E4%BA%8B%E5%8A%A1%E5%B7%A5%E4%BD%9C%E6%B5%81/</id>
    <published>2020-10-21T23:14:04.000Z</published>
    <updated>2021-06-29T22:50:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>出自《GTD搞定无压的艺术》横向管理工作流的五个阶段。</p><span id="more"></span><!-- toc --><h3 id="横向管理工作流程的五个阶段"><a href="#横向管理工作流程的五个阶段" class="headerlink" title="横向管理工作流程的五个阶段"></a>横向管理工作流程的五个阶段</h3><p>我们在工作时都将经理这五个阶段：</p><p><strong>（1）收集（Collect）一切引起我们注意的事务和信息；</strong></p><p><strong>（2）对这些信息进行处理（Process），决定下一步行动；</strong></p><p><strong>（3）对这些行动进行有效的组织整理（Orgainze）；</strong></p><p><strong>（4）我们通过回顾（Review）来确定下一步行动方案；</strong></p><p><strong>（5）行动（DO），直至完成最终工作。</strong></p><p>这些阶段共同构成了我们生活中的“横向”管理系统，而且我们还可以随时向其中添加任何引起关注的新事物。</p><p>了解了这5个阶段的本质和相互关系后,还需要运用一些有效的技巧和工具,才能顺利地完成各阶段的工作任务。我发现,如果将这5个步骤分开来做,会取得更好的效果。有时候,我只收集各种信息,而不做进一步处理。而有时,我又只进行分析和处理(比如利用会议后的间隙,整理会议笔记),我还会利用长途旅行的路上时间,对收集和分析处理后的材料进行组织整理。还有一些时候,我会查看我的工作清单,回顾检查我的工作状况。很显然,大部分时间我都会充分利用起来,去做我该做的事情。</p><p>许多人无法把工作安排得井井有条,主要原因是他们试图一口气完成这5个阶段的工作。当他们坐下来“开列工作清单”时,大多数人试图按照重要性和紧急程度来罗列“最重要的事情”,但他们却没有拟定任何具体的行动方案。如果你因为某些事情(比如秘书的生日)目前“并非那么重要”,而暂时将它搁置一旁不作任何考虑,那么这件事就成了一个悬而未决的问题。而它也将时刻消磨你的精力,阻碍你集中精力思考那些真正重要的事情。</p><h4 id="（1）收集（Collect）"><a href="#（1）收集（Collect）" class="headerlink" title="（1）收集（Collect）"></a><strong>（1）收集（Collect）</strong></h4><p><strong>我们首先需要了解该收集哪些信息,以及如何有效地完成这一工作,这一点非常重要。只有这样,你才能有效地进行下一步的处理。为了把大脑从那些低层次的、希望抓住一切事务的意识中解放出来,你必须(利用工作篮)百分之百地捕获一切“未尽事宜”。而且在将来的某个时间,你还将处理和回顾这些“未尽事宜”。</strong></p><p><strong>你需要寻找和收集你世界中的一切未尽事宜,无论大小、轻重、缓急,只要是那些等待处理的、需要改进的、引起注意的事务,都要收集起来。</strong></p><p><strong>在你读到这里的时候,许多事务正处于收集之中。信箱里收到了新的信件,工作篮中增添了新的备忘录,电脑中收到了新的电子邮件,语音信箱收到了新的留言。但与此同时,你也正在从周围的环境中收集引起你注意的信息,并储存到自己的大脑,而且大脑自己还会不停地思考,时不时地形成一些想法和主意,它们也需要你的关注。这些信息不像电子邮件那样醒目,但它们也是“材料”,需要用某种方法对其进行处理,所以也是收集的对象。比如:在记事簿上记录的某些决策,应该尽快付诸实施;在你书桌的抽屉里,某些不好用的文具需要修理一下或者干脆扔掉;在你的咖啡桌上,放着一些过期的杂志-这些全都属于“材料”的范畴。</strong></p><p><strong>一旦你给某一事务贴上“需要做”或者“应当做”的标签,它就变成了一件“未尽事宜”。比如,如果你还在犹豫某件事是否需要完成或如何完成,那么它就是“未尽事宜”。这包括全部的“我将要 ,也就是那些你已经有所计划但是尚未付诸行动的事情。当然,未尽事宜还包括所有正在处理中、尚未结束的事务,以及那些你已经实施但尚未最终确认完成的事务。</strong></p><p><strong>为了正确地管理这些“未尽事宜”,你需要暂时把它们全部放入一个“存储器”中。等到有时间的时候再来确定它们到底都是一些什么样的问题,需要如何处理和解决。为了确保这个收集工具的有效性,你必须定期清空这些“存储器”。</strong></p><p><strong>如果你将大脑也当做一个“存储器”来看待的话,那么很可能各种“未尽事宜”现在就已经被你收集起来了。但是如果无法找到一个可靠的外在体系对它们进行直接管理,那这些事情必定会藏匿于你脑中的某个角落,并且无法有效地定期清空。事实上,如果你没有把某项任务放入你的工作篮,那它就必定存在于你的大脑当中。</strong></p><p><strong>我们在这一阶段所要做的,正是要确保一切必要的事情统统得到了收集,并且存储在你大脑之外的某个地方。</strong></p><p><strong>影响成功收集的因素</strong></p><p><strong>遗憾的是,仅仅有合适的收集工具,并不能保证顺利完成所有收集工作。大多数人都拥有某种形式的收集设备,但是,这些设备或多或少地存在失控的情况。我们一起来看看成功收集的三个必要条件:</strong></p><p><strong>1,每一件悬而未决的事情都必须存储在你的收集系统中,而不是在你的大脑里。</strong></p><p><strong>2,你应该尽可能地控制收集工具的数量,越少越好,够用即可。</strong></p><p><strong>3,你必须定期清空这些设备。</strong></p><h4 id="（2）处理（Process）"><a href="#（2）处理（Process）" class="headerlink" title="（2）处理（Process）"></a><strong>（2）处理（Process）</strong></h4><p>它是什么?</p><p>这个问题并不愚蠢。我们前面已经讨论了收集工具以及收集的“材料”。但是,我们还没有讨论过这些材料到底是什么,需要我们如何处理。比如,我们从上级主管处接收的很多信息,往往因为含糊不清,而很容易被我们的个人组织整理系统漏掉,我们是不是应该先搞清楚这些信息的含义呢?当我们收到人力资源部门发来的电子邮件,通知我们某某政策的某某情况时,我们是不是也需要先看清楚邮件内容?我曾经从我的客户那堆积如山的文件中,挖掘出十多条有价值的信息,这仅仅是由于他们当时不愿意花上几秒钟的时间来搞清楚文件内容就随手一扔造成的。搞清楚了这个问题,我们也就可以了解下一步决策的重要性了。</p><p><img src="https://i.loli.net/2021/06/05/y7gMeXvWHQ5RLSO.png" alt="image-20210605063922106"></p><p><strong>是否需要采取行动?</strong></p><p>对于这个问题有两种回答:是和否。</p><p><strong>不需要采取行动</strong></p><p>如果答案是“否”,也就是“它”不需要我们采取任何行动,那么就有三种可能的情况:</p><p>1,这是无用的垃圾,我们根本就没必要保留它。</p><p>2,目前没有采取行动的必要,但是日后可能需要处理(孵化,酝酿)</p><p>3,该信息具有潜在的利用价值,今后也许能派上用场(参考资料)。</p><p>这三种情况各自都有一套处理方法,我们将在后面的章节中详细介绍。就目前而言,对于要删除的东西,你所需要的就是一个垃圾箱和删除键;对于那些需要在日后处理的事情,就将它们写在备忘录或者日程表中;对于那些有潜在价值的参考资料和信息,把它们放在一个完善的归档系统中保存就可以了。</p><p><strong>需要采取行动</strong></p><p>这一类材料要求我们亲自着手处理。典型的情况可能是一封要求你在某日参加公司活动的电子邮件,或者是与集团副总裁会面后放在工作篮中的备忘录,写着聘请顾问这一重要新项目的相关事宜。</p><p>面对这类需要着手处理的材料时,你必须回答两个问题:</p><p>1.你承诺完成哪些工作?需要达成哪些目标?</p><p>2,具体的下一步行动是什么?</p><p><strong>如果它代表一个项目</strong></p><p>如果手头的事情需要一系列的行动才能实现它的目标或结果,你就可以将其视为一个项目并将它列入“项目”清单中。这如同在地上树起一个树桩,提醒你有些目标尚未达成。每周回顾一下这个清单(参见“成功的关键因素:每周回顾”一节)将会帮助你想起这个尚未解决的问题。这些目标会一直保存在你的管理系统中,直到你达成或者放弃这个目标。</p><p><strong>下一步要采取什么行动?</strong></p><blockquote><p>做事情时,并不需要花费很多心力,但是在决定做什么时,却要投入大量的精力。</p><p>-阿尔伯特·哈伯德(Elbert Hubbard)</p></blockquote><p>对于你所收集到的任何材料来说,这都是一个关键的问题,如果你能给出合适的答案,你便拥有了下一步组织整理工作的基本原料。“下一步行动”是指那些可执行、可操作的具体行动,并且只有将其完成之后才能推动整个事情向着既定目标发展。</p><p>“下一步行动”的几个例子:</p><p>·给弗雷德打个电话,问他推荐的那家修理厂的电话号码。</p><p>·起草预算会议的具体议程。</p><p>·与安吉拉谈论我们需要建立的文件归档系统。</p><p>·上网了解一下数据库管理软件的知识。</p><p>这些都是需要我们实施的真实而具体的行动,这些行动的提示信息将对个人管理系统是否有效起到决定性作用。</p><p><strong>立即执行、指派他人,或者延迟处理</strong></p><p>一旦你决定了下一步行动,紧接着,你就会面临以下三种选择:</p><p>1,立即执行。如果这步行动能在两分钟内完成,那么你就应该立刻执行。</p><p>2,指派他人。如果处理这件事情需要花费的时间不止两分钟,那么,你应该问一问自己是否就是解决这个问题的最佳人选。如果回答是否定的,那就委托给一个合适的人员去办理。</p><p>3,延迟处理。如果预计花费的时间超过两分钟,而你又恰恰是最佳人选,那么这时,你就不得不推迟行动,并把它记录在“下一步行动”清单上，以后再来完成。</p><hr><p>日程表</p><p>行动的提示信息可以分为两类:一类是需要在某一指定日期或时间里执行的行动提示信息,另一类是应该尽快完成的行动提示信息。而日程表所负责记录的就是第一类行动提示信息。</p><blockquote><p>  你的日程表上只标注三种情况:</p><p>  需要在指定时间执行的行动。</p><p>  需要在指定日期执行的行动。</p><p>  需要在指定日期获取的信息。</p></blockquote><p><strong>需要在指定时间执行的行动</strong></p><p>这其实是给约会起了一个花里胡哨的别名。比如说,某项目的下一步行动是参加某日某时召开的会议,你只需把它标注在日程表的对应时间点上就可以了。</p><p><strong>需要在指定日期执行的行动</strong></p><p>-些事情需要在某个特定的日期进行,但不一定非得苛求于某个确定的时间。也许你告诉玛丽星期五会给她打电话,问问你给她的报告有没有问题。因为她星期四才可能拿到报告,而星期六又要出国,因此星期五是采取行动的最佳时机,但在这一天的哪个时间采取行动是无关紧要的。那么,只要标注在那一天的工作日历中就行了。所以,将指定时间的行动和指定日期的行动在日历中分开标往是非常实用的。</p><p><strong>需要在指定日期获取的信息</strong></p><p>有时候,你需要在特定的日期了解某些信息,但是并不一定要采取行动,这样的事情,也可以记录在日程表中,用以提醒自己。比如有关安排约会的注意事项,他人(家人或员工)的日程安排,或者是其他对你有用的信息。同时,你也可以在日程表中记载一些短期的提示信息,如提醒自己等某人度假回来以后,给他打个电话等。</p><p><strong>不再需要“每日工作清单”</strong></p><p>在我的做法中,只有上面那三种情况才允许被记录在日程表中,其他的一概免谈!我知道,这对于传统的时间管理方法来说,简直如同异端邪说。按照传统的时间管理方法, “每日工作清单”就是一剂百试不爽的灵丹妙药。但实际上,这种工作清单的收效却令人大失所望,这主要有以下两个原因。</p><p>首先,由于会不断出现新的问题需要处理,工作的重点也可能不断地转移,每天的工作安排也必将随之作出相应的调整,因此,人们不可能100%提前确定每日工作清单。制定一个工作清单作为工作参照自然是有益处的,但是,实际情况是这个工作清单可能不得不随时进行调整。如果你在日程表中记下一串长长的任务,一旦无法执行,又不得不将它们的内容逐项重新抄录到另一个日期里,这未免有些令人泄气,同时也浪费了宝贵的时间。我提倡使用的“下一步行动”清单能够容纳所有行动的提示信息,甚至是那些有严格时间要求的行动。这样就避免了每天在日程表中重复抄写同样的任务了。</p><p>其次,如果日程表上的某一项工作不一定非要在这一天中完成,那么,它将对其他工作起到弱化作用,并造成一定的负面作用。比如说,我必须在星期五给某人打个电话(因为我只有在那一天才能找到她),然而同时,我又在那一天的日程安排中挤进了其他5个电话,它们无足轻重,也不存在严格的时间限制。如果那一天我忙得晕头转向的话,就可能把给某人打电话的事情给抛到九霄云外了。这样就必须让大脑提醒自己:这个电话必须要打,否则我不可能再有其他的机会了。依我看,日程表是一块神圣的领地。一旦在那里标记了某个行动,你就必须在那个特定的时间完成,而在别的时间则根本不用考虑这个行动。</p><p>只有在约会本身发生变动的时候,才允许在日程表中进行相应的变更。</p><h4 id="（3）组织整理（Organize）"><a href="#（3）组织整理（Organize）" class="headerlink" title="（3）组织整理（Organize）"></a><strong>（3）组织整理（Organize）</strong></h4><p><strong>在工作流程图的外围,是8个独立的处理方向,这包含了你的“材料”经过处理后可能遇到的所有情况。将它们综合在一起,就构成了一个完整的系统。这个系统可以组织整理你的当前工作，也可以随时接纳新内容。</strong></p><p>对于那些无须采取行动的事务来说,可以将它们:丢入垃圾桶、保存为等待酝酸的资料或归档为参考资料。如果某项事务无须采取行动,你可以把它当成垃圾丢掉,也可以“存入备忘录”以备日后再次评估,还可以归档保存起来以便今后能够随时查阅。对于那些可以付诸行动的事务,你则需要:一个项目清单、一个保存项目规划和资料的存储系统、一个日程表、一个下一步行动清单,以及一个等待清单(清单中包含的内容是那些等候别人完成的任务)。</p><p>由此可见,这8类事务都可以(而且也应该)分别放入几个客观存在的容器中。本书中我们将这种容器统称为“清单” (list),意思是可供人们经常查阅的一组提示信息。这个“清单”可能是纸质的备忘录手册,也可能是一个电脑程序,还可能是塞满纸质文件的文件夹。举个例子来说吧,一个当前项目清单,可以是记事本中写满个人目标的一页纸,也可以是个包含任务列表的PDA,或者是个贴着“项目清单”标签的塑料文件夹。提示信息(如”3月1日后,与我的会计师联系,约定一次会面”)既可以保存在书面形式的备忘录文件夹中,也可以存放在纸质或者电子日程表内。</p><h4 id="（4）回顾"><a href="#（4）回顾" class="headerlink" title="（4）回顾"></a><strong>（4）回顾</strong></h4><p>如果你按照所推荐的方法建立起个人的组织整理系统,那么拥有一个“项目”清单、一个日程表、“下一步行动”清单(一个或多个)和一个“等待处理”清单就是回顾的全部内容。</p><p>这其中,浏览最为频繁的大概要数日程表了,它会提醒你这一天里的“必做任务” (这些任务如果不在这一天完成,便没有机会完成了)。这并不意味着这些写入日程表的事情就是最为“重要”的,其实,它们只不过是不得不在这一天完成的事情。在任何时候,只有在对不得不完成的事情和其要求的时间都了如指掌的情况下,你才有可能更加机动灵活地安排其他工作。处理日程表的最好方式是,将上面罗列的任务(如开会、打电话、完成报表的最终稿等)逐项完成,不要遗漏。</p><p><strong>成功的关键因素:每周回顾:</strong></p><p>一切需要采取行动的事情,我们都应当对其进行定期的回顾,以使我们的大脑不再花费精力来记忆和回想这些事情。我们无时无刻不在凭借我们的直觉对某些行动作出快速的判断,要保证这些判断的正确性,我们也必须有机会从更高的角度俯看全局。根据我的经验(这也是成千上万人总结出来的经验),使这些事项转化为行动的关键就是:每周回顾。</p><p>所有悬而未决的事务: “项目”清单(包括现行项目规划)、“下一步行动”、“议事日程”、“等待处理”,甚至“将来/也许”清单,都应该每周回顾一次。你自己也同时得到一次机会,确认大脑中无牵无挂,而且过去几天中的零星琐事已经统统被收集、处理并组织起来了。</p><h4 id="（5）执行"><a href="#（5）执行" class="headerlink" title="（5）执行"></a><strong>（5）执行</strong></h4><p>这个工作流程管理系统的基本目标是,为你任何时候能作出的正确选择提供支持。</p><p>星期一上午10点33分,你犹豫不决,是给桑迪打个电话处理某个提案,还是回复一封电子邮件呢?一切跟着感觉走。但是,如果事前已做了计划,那么你对自己的决定就会表现出十足的信心。你对自己行动的态度将从期望升级为信任,由此将大大提高你行动的速度和效力。</p><h5 id="选择行动方案的三种方法"><a href="#选择行动方案的三种方法" class="headerlink" title="选择行动方案的三种方法"></a>选择行动方案的三种方法</h5><ol><li><p><strong>确定某一时刻具体行动的“四标准法”</strong></p><p>在星期三下午3点22分时,你如何选择下一步行动呢?你可以按顺序采用下面四个标准:</p><pre><code>1. 情境2. 有多少时间3. 有多少精力4. 重要性</code></pre><p><strong>情境</strong>-只有很少一部分事情对地点没有什么特别的要求(像拿一支钢笔和一张纸就可起草对一个项目的想法),但是,大多数事情都只能在特定的地点完成(在家或办公室),或者需要借助某些特定的工具(如一部电话、一台电脑),而这正是限制我们选择行动的首要因素。</p><p><strong>有多少时间</strong>-你所能支配的时间长短也是一个重要的限制因素。如果5分钟后你就必须去开会,你现在就不可能去执行那些耗时更久的行动。</p><p><strong>有多少精力</strong>-你有多少精力呢?某些事情需要你头脑清醒、思路清晰、富于创造力,而另一些则要求你具备充沛体力。除此之外的一些事情则对这两方面都没有特别要求。</p><p><strong>重要性</strong>-当你考虑了情境、时间、精力这三个条件后,你就要选择哪个行动会给你最高的回报了。现在,你有1个小时的时间,你坐在办公室里守着电话和电脑,你的精力指数为7.3 (最高为10),你应该做些什么呢?给客户回一个电话?考虑一下新的提案?处理一下语音信箱里的留言和电子邮件?或者联系一下你的配偶,看看她/他这一天过得怎么样?</p><p>这时,你可以惜助你的直觉,并依赖你此时此刻的判断力。</p><p>了进一步探究这个问题,我们再来讨论一下另外两种模式,看一看怎样找到目前最重要的事情。</p></li><li><p><strong>评估每日工作的“三分类法”</strong></p><p>当你着手处理事务,也就是人们在一般情况下提到的“工作”时,你可能是在从事以下3种不同类型的活动:</p><pre><code>1. 执行事先安排好的工作2. 处理突发事件3. 安排自己的工作</code></pre><p><strong>执行事先安排好的工作</strong>-当你执行事先安排好的工作时,你实际上是在按照“下一步行动”清单,不断地向前推进着去落实那些你早已经确定了的行动,并控制工作流程的运转。例如,按照电话清单拨打电话,或者记录头脑风暴的成果,或者起草要同律师磋商的问题清单。</p><p><strong>处理突发事件</strong>-通常会有一些预料之外的事情突然冒出来,你可能不得不放下手头的工作来应对这些紧急情况。例如,你的合作伙伴走进了你的办公室,希望同你谈一谈新产品发布的安排情况,结果你就放下手头正在处理的工作同她聊了起来。每天你都会碰到一些突发事件,你肯定会为此付出一定的时间和精力。但如果你转而处理这些突发事件,那就证明你认为这些事情要比你必须完成的那些工作更加重要。</p><p><strong>安排自己的工作</strong>-安排你的工作,这包括清空你的工作篮,处理你的语音留言和电子邮件,整理你的会议记录,并把一项项新工作分解成多项具体的、可操作的行动。在你加工这些信息的过程中,毫无疑问,你随手解决了那些用不了两分钟就可以完成的事情(处理突发事件的另一种形式),同时把其他数不胜数的事情分类归档。在这个过程中,相当大的一部分工作是明确那些不需要立刻执行的行动,并将它们分门别类地编入你的行动清单。</p><p>一旦你完成了对工作的安排,你也就完成了行动清单的更新。</p><p>有了这些行动清单,再根据情境、时间、精力进行筛选,你就能得出需要着手处理的具体任务了。</p></li><li><p><strong>总体检视工作的“六层次法”</strong></p><p>事情的重要性是决定你行动选择的基本根据。但是,并没有一个可靠的模型或工具能够帮助你确定实际工作中各项任务的优先级。为了明确到底哪些工作才是最重要的,我们必须首先搞懂我们工作到底是为了什么。至少可以从六个不同的层次对此进行审视。</p><p>我们可以用高度的概念进行类比:</p><pre><code>1. 五万英尺以上：人生。2. 四万英尺：3~5年的展望。3. 三万英尺：1~2年的目标。4. 二万英尺：责任范围。5. 一万英尺：当前项目/目标。6. 跑道：目前的行动。</code></pre><p>让我们由下至上入手。</p><p>跑道:目前的行动–在你的行动清单上,堆积着需要处理的一切事务:所有你需要打的电话,所有等待回复的电子邮件,所有要外出处理的事情,还有你打算向老板汇报的日程安排,以及希望同配偶交流的信息。即使地球停止转动、你不再接收更多的任务和信息,你大概也要忙碌300-500小时,才能把这些事情一一解决。</p><p>1万英尺:当前的项目/目标-当前需要完成的工作,通常数量在30-100项之间。这些都是你希望在相当短的时间内取得成效的事情。例如,为家里购置一台电脑,组织一次销售会议,把公司总部迁往新址,去看牙医等。</p><p>2万英尺:责任范围-自身承担的种种责任和义务,也是让你承受了先前的大部分工作的原因。对于大多数人而言,这些责任和义务可以划分为10-15个范畴。在这些重点领域里,你希望取得成果或者保持现有的水准。在工作方面,你的责任可能包括若干方面,如战略计划、行政支持、员工培训、市场调研、客户服务或者资产管理。此外,你的个人生活中也有很多领域需要你关注:健康、家庭、财务收支、住宅环境、宗教信仰、娱乐休闲等。把所有这些责任和义务一并诉诸文字,并经常回顾和自检,将有助于你更加综合全面地对自己的项目清单进行分析和评估。</p><p>3万英尺: 1-2年的目标-在生活的不同领域,你希望有哪些新的体验;通过1~2年的努力,要为自己的工作开创一个什么样的新局面。随着一些新的责任和义务的产生,你需要经常调整自己的工作重心,以完成所制定的目标。在个人生活领域,情况也大同小异,你希望某些事情尽快完成或到位,这将增加你对生活中某些方面的关注,同时减少对其他方面的关注。</p><p>4万英尺: 3-5年的展望-展望未来3-5年的发展前景,你必定会从一个更加广阔的角度着眼:管理策略、周边环境发展的趋势、事业和生活转变的条件。内在的因素包括事业、家庭和财务方面的长期目标,外部因素包括技术进步、全球化进程、市场趋势及竞争等:这些势必都会影响到你的工作和组织整理方法。而在这一层面的决策将会轻而易举地影响前述各个层面的内容。</p><p>5万英尺以上:人生–这就是我们整个生活的全景。你的公司为何存在?你自己为何存在?事物的核心意义会指明它的发展方向。本层是整个检视系统的最高层,是生活的终极指南。你制定的所有目标、前景展望、规划、行动都由此决定,也都为此服务。</p><p>以上这种在高度方面的类比多少有些主观。在现实中经常出现的关于生活或工作的重要话题,可能无法准确地划入上面描述的某一个具体层次,然而,这种多层次的思考方法会为你提供一个有效的思维框架,帮助你认识到工作以及相关的义务和责任都具有的多个层面的本质。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;出自《GTD搞定无压的艺术》横向管理工作流的五个阶段。&lt;/p&gt;</summary>
    
    
    
    <category term="阅读笔记" scheme="https://blog.methodref.top/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="书籍" scheme="https://blog.methodref.top/tags/%E4%B9%A6%E7%B1%8D/"/>
    
    <category term="心理" scheme="https://blog.methodref.top/tags/%E5%BF%83%E7%90%86/"/>
    
    <category term="管理" scheme="https://blog.methodref.top/tags/%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>改变习惯的步骤方法</title>
    <link href="https://blog.methodref.top/2020/10/18/8.%E6%94%B9%E5%8F%98%E4%B9%A0%E6%83%AF%E7%9A%84%E6%AD%A5%E9%AA%A4%E6%96%B9%E6%B3%95/"/>
    <id>https://blog.methodref.top/2020/10/18/8.%E6%94%B9%E5%8F%98%E4%B9%A0%E6%83%AF%E7%9A%84%E6%AD%A5%E9%AA%A4%E6%96%B9%E6%B3%95/</id>
    <published>2020-10-18T09:12:09.000Z</published>
    <updated>2021-06-29T22:49:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自于《习惯的力量》中改变习惯的步骤和方法。</p><span id="more"></span><!-- toc --><h3 id="改变习惯的步骤方法"><a href="#改变习惯的步骤方法" class="headerlink" title="改变习惯的步骤方法"></a>改变习惯的步骤方法</h3><p>有些习惯很容易会被分析和影响折服。其他习惯则更复杂，也更顽固，需要对它们进行长期的研究。对人而言，改变习惯是一个永远都不会完全结束的过程。<br>但这并不意味着习惯无法改变。本书每一章都从不同的角度为读者解释了习惯存在的原因以及习惯的运作方式。本附录中提到的理解框架试图从非常基本的角度，提炼研究人员找到的，用来分析并改变我们生活中各种习惯的方法。本书并不想做到无所不包，只是提供一个实践指导，一个开端。配合本书各章节更加深入的内容，这本书就是告诉你今后该如何做的指南。<br>改变可能不会很快，而且并不总是容易。但只要付出时间和努力，几乎所有的习惯都是可以改变的。<br>理解框架：</p><ul><li><strong>找出惯常行为</strong></li><li><strong>用各种奖赏进行试验</strong></li><li><strong>将暗示隔离出来</strong></li><li><strong>制订计划</strong></li></ul><h4 id="第一步：找出惯常行为"><a href="#第一步：找出惯常行为" class="headerlink" title="第一步：找出惯常行为"></a><strong>第一步：找出惯常行为</strong></h4><p>麻省理工学院的研究人员在每种习惯中发现了一种简单的神经逻辑回路，这种回路包含三部分：暗示、惯常行为和奖赏。</p><p><img src="https://i.loli.net/2021/06/05/yrcinIGYNsUfTZJ.png" alt="image-20210605080113262"></p><p>了解自己的习惯，你得找到回路的各个部分。一旦发现行为中存在的习惯回路，你就能想办法用新的惯常行为取代旧的坏习惯。<br>比如你有一个坏习惯，就像我为撰写本书做研究时的习惯一样，喜欢每天下午去咖啡厅买巧克力豆饼干。假设这个习惯让你胖了几磅，或者说这个习惯实际上让你胖了8磅，然后你妻子针对你的体重说了一些让你不爽的话。于是你总是强迫自己停止吃饼干，但徒劳无益，你觉得很累，你甚至还在电脑上贴了即时贴，写着再也不吃饼干了。但是每天下午你都会当这张即时贴不存在，照样晃悠着去咖啡厅，然后买饼干，接着在收银台附近与同事闲聊时就开始吃。吃的时候感觉很好，吃完就难受了。你跟自己发誓，说你明天会用全部的意志力来抵制饼干的诱惑，明天会是新的一天。</p><p>不过第二天这个习惯照旧。<br>你怎样开始分析，然后改变自己的行为呢？<br>就是要弄清楚自己的习惯回路。第一步是找出自己的惯常行为。饼干的案例和大部分习惯一样，其中的惯常行为几乎是最明显的，是你想要改变的行为。你的惯常行为是下午从桌子旁起来，走到咖啡厅，买巧克力豆饼干，然后在和朋友聊天的时候吃，那么这就是你加入到习惯回路中的东西。</p><p><img src="https://i.loli.net/2021/06/05/ze7df13aru2nEgF.png" alt="image-20210605080325208"></p><p>接着，还有一些较为隐蔽的问题：这一惯常行为的暗示是什么？是饥饿吗？是无聊吗？是因为低血糖？还是说你在全身心投入到下一件工作前，需要休息下，而吃饼干就是休息的一种方式？<br>那么奖赏是什么？是饼干吗？还是换了环境？或者是暂时散散心？又或者是与同事聊天？也有可能通过突然摄入那么多糖获得了能量充沛的感觉?<br>要弄清楚究竟怎么回事，你需要做点儿实验。</p><h4 id="第二步：用奖赏做实验"><a href="#第二步：用奖赏做实验" class="headerlink" title="第二步：用奖赏做实验"></a><strong>第二步：用奖赏做实验</strong></h4><p>奖赏的影响力很大，因为它们能满足人的渴求感。但人往往意识不到在背后驱动我们行为的渴求。比如，纺必适营销团队发现消费者在每次例行清洁后需要新鲜的气味，他们找到了一种任何人都不曾意识到的渴求。其中的奥秘就在眼前。回想一下，就会发现大多数渴求都非常明显，但我们就在它们面前却视而不见，这实在令人难以置信。<br>为了确定是哪些渴求在驱动习惯，就要用不同的奖赏做实验。</p><p>这也许会花几天、一周或者更长的时间。在这段时间里，你在做出切实的改变时不应该感到任何压力，把自己想象成数据收集阶段的科学家就行。<br>在实验的第一天，你会非常想去咖啡厅买饼干，那么你得调整一下你的惯常行为，这样会得到不同的奖赏。比如，你没有去咖啡厅，而是在社区附近散步，然后回到办公桌前，什么也没吃。第二天，你去咖啡厅买了个甜甜圈，或者糖果条，然后回到桌子那儿吃。第三天你去了咖啡厅买了个苹果然后和朋友聊天的时候吃了。接着你试着换成麦咖啡，然后你都不用去咖啡厅了，而是直接到朋友那里去闲聊几分钟，然后回去工作。</p><p>你选择使用什么行为取代买饼干并不重要，重要的是在测试阶段确定那种渴求在驱动你惯常行为。如果你是因为渴求饼干本身，那是因为你饿了吗？（如果是这样，苹果也可以满足你。）</p><p>或者是因为你需要饼干提供的能量？（如果是这样，咖啡应该可以满足你。）</p><p>或者，你走去咖啡厅是因为你想要找人闲聊，而饼干不过是个比较好的借口？（如果是这样，走到别人办公桌前，和对方闲聊几分钟，应该也能满足你的冲动。）</p><p>等你尝试了四五种不同的奖赏后，你就可以用老办法寻找其中的规律了：</p><p>每次活动之后，拿支笔在纸上写下你一回到桌前就想到的头三件东西。可以是你的情绪或者思维，或者写下自己的感觉的想法，要么就写出头三个你想到词语。</p><p>然后，设置一个15分钟的闹钟。等到闹钟响起，你就问自己是否还有吃饼干的冲动。</p><p>写下这三样东西非常重要，就算写下的词毫无意义，你也要写，原因有两个。其一，这样做会迫使你此刻意识到自己在想什么或者感觉如何。其二，研究表明，写几个单词有助于你今后回忆起自己当时在想什么。在实验结束时，如果你回顾自己的笔记，就能很容易记起当时的想法，在那一刻究竟是什么感觉。因为你写下的东西会帮助你进行全面的会议。</p><p>为什么要定下15分钟的闹钟？以为这些测试的重点是找出你渴求的奖赏是什么。如果吃掉甜甜圈15分钟后，你还是有冲动去咖啡厅，那驱动你的习惯就不是对糖的渴求。如果和同事闲聊后，你还是想吃饼干，那么与人接触的需求就不是你吃饼干行为的诱因。</p><p>通过不同的奖赏习惯进行试验，你可以将你实际渴望的对象分隔出来，这就是重塑习惯的基本要素。</p><p>一旦你找到了惯常行为和奖赏，剩下要做的就是找到暗示了。</p><h4 id="第三步：分隔出暗示"><a href="#第三步：分隔出暗示" class="headerlink" title="第三步：分隔出暗示"></a><strong>第三步：分隔出暗示</strong></h4><p>几乎所有的习惯性暗示都可以归为以下五大类中的一类：</p><ol><li> <strong>地点</strong></li><li> <strong>时间</strong></li><li> <strong>情绪状态</strong></li><li> <strong>其他人</strong></li><li> <strong>之前紧挨着的动作</strong></li></ol><p>所以如果你想找到“去咖啡厅并买巧克力豆饼干”这个习惯的暗示，那请在这一冲动出现时写下5样东西（下面这些是我在分析自己的习惯时做的笔记）：<br>你在哪？（坐在我的办工桌前）<br>现在几点？（下午3点36分）<br>你的情绪怎样？（觉得无聊）<br>周围有谁？（空无一人）<br>在买饼干的冲动之前，你做了什么？（我回复了一封电子邮件）<br>第二天：<br>你在哪？（从复印机那儿往回走）<br>现在几点？（下午3点18分）<br>你的情绪怎样？（觉得开心）<br>周围有谁？（体育部的吉姆）<br>在买饼干的冲动之前，你做了什么？（我复印了一份东西）<br>第三天：<br>你在哪？（会议室）<br>现在几点？（下午3点41分）<br>你的情绪怎样？（累，对自己正在做的项目感到激动）<br>周围有谁？（其他来开会的编辑）<br>在买饼干的冲动之前，你做了什么？（我坐了下来，因为会议要开始了）<br>有这三天的记录，已经可以清楚地看到是什么暗示诱发了我买饼干的习惯，让我每天在固定的时间有吃零食的冲动。在第二步我就发现我有这个习惯并不是因为饿。我找寻的奖赏是暂时散散心，也就是通过与朋友闲聊得到消遣。我现在知道这一习惯诱发的时间是在下午3点到4点之间。</p><h4 id="第四步：制定计划"><a href="#第四步：制定计划" class="headerlink" title="第四步：制定计划"></a><strong>第四步：制定计划</strong></h4><p>一旦你发现了你的习惯回路，你就找到了驱动你行为的奖赏、诱发你习惯的暗示以及惯常行为本身，这样你就可以开始改变你的行为了。通过围绕暗示设计，选择能够满足你所渴“求的奖赏的行为，你就可以改善你的习惯。你需要的是一个计划。在前言中，我们了解到习惯是一种在特定的时间，你会做出的选择，然后你便不会再去想，却会日复一日地重复它。<br>换句话说，习惯是大脑自动遵循的行为模式，也就是我看到暗示时，我会做出惯常行为，目的是要得到奖赏。为了调整这个模式，我们需要重新进行选择。许多研究表明，这样做最容易的方式是制订计划。在心理学里中，这些计划被称为“执行意图”。<br>比如，拿我在下午买饼干的习惯作为例子，通过这个框架，我发现我的暗示一般大约出现在下午的3点半。我知道我的惯常行为是去咖啡厅买饼干，同时还与朋友聊天。通过实验，我发现我渴求的并不是饼干本身，而是那一小段时间的悠闲以及与别人交往的机会。<br>于是我为自己制订了计划：<br>每天下午3点半，我会到朋友的办公室和他聊上10分钟。<br>为了确保我记得这样做，我在手表上设了下午3点半的闹钟。<br>这样做并没有立刻收到效果。我有时候太忙了，都忘记自己设了闹钟，然后旧瘾复发。其他时候好像是工作太多，要找个愿意跟你聊的朋友很难，而买饼干很简单，于是我又在冲动面前投降了。但在我按照自己的计划行事的日子里，每次闹钟一响，我就强迫自己走到朋友办公桌那和他聊上10分钟，我发现我每天工作结束时感觉更舒坦了。我没去咖啡厅，也没有吃饼干，而我依然感觉良好。最终，这变成了自发行为：每次闹钟一响，我就去找朋友，然后每天结束时，内心都有一种细微但是真实的成就感。几个星期以后，我不再去想自己的这种惯常行为了。等到我找不到人可以聊天“时，我就去咖啡厅，和在那里的朋友们一起喝茶。<br>这一切都发生在6个月之前。我现在都不戴表了，因为丢了。但是，每天下午的3点半，我依然不知不觉地站起来，看看新闻编辑室里谁有时间可以和我闲谈，花10分钟时间聊聊新闻，然后回去工作。现在这一切都是在我不假思索的情况下发生的，这已经变成了一种习惯。</p><p>显然，改变某些习惯很难，但是这个框架是一个好的开端。有时候改变习惯要花很长的时间，有时候会经历反复的实验与失败。不过，一旦你弄清楚了习惯背后的机理，也就是你能够分析出暗示、惯常行为和奖赏时，你就有了超越习惯的力量。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自于《习惯的力量》中改变习惯的步骤和方法。&lt;/p&gt;</summary>
    
    
    
    <category term="阅读笔记" scheme="https://blog.methodref.top/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="书籍" scheme="https://blog.methodref.top/tags/%E4%B9%A6%E7%B1%8D/"/>
    
    <category term="研究" scheme="https://blog.methodref.top/tags/%E7%A0%94%E7%A9%B6/"/>
    
    <category term="心理" scheme="https://blog.methodref.top/tags/%E5%BF%83%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>《代码整洁之道》阅读笔记</title>
    <link href="https://blog.methodref.top/2020/10/12/7.%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>https://blog.methodref.top/2020/10/12/7.%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</id>
    <published>2020-10-12T06:49:27.000Z</published>
    <updated>2021-06-29T22:51:13.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li> 阅读本书有两种原因：第一，你是个程序员；第二，你想成为更好的程序员。</li><li> 这是本有关编写好程序的书。它充斥着代码。我们要从各个方向来考察这些代码。从顶向下,从底往上,从里而外。读完后,就能知道许多关于代码的事了。而且,我们还能说出好代码和糟糕的代码之间的差异。我们将了解到如何写出好代码。我们也会知道,如何将糟糕的代码改成好代码。</li></ol><span id="more"></span><!-- toc --><h3 id="第1章-整洁代码"><a href="#第1章-整洁代码" class="headerlink" title="第1章 整洁代码"></a>第1章 整洁代码</h3><ul><li><h4 id="糟糕的代码"><a href="#糟糕的代码" class="headerlink" title="糟糕的代码"></a>糟糕的代码</h4><p>  你当然曾为糟糕的代码所困扰过。那么-为什么要写糟糕的代码呢?</p><p>  是想快点完成吗?是要赶时间吗?有可能。或许你觉得自己要干好所需的时间不够;假使花时间清理代码,老板就会大发雷霆。或许你只是不耐烦再搞这套程序,期望早点结束。</p><p>  或许你看了看自己承诺要做的其他事,意识到得赶紧弄完手上的东西,好接着做下一件工作。</p><p>  这种事我们都干过。</p><p>  我们都曾经瞟一眼自己亲手造成的混乱,决定弃之而不顾,走向新一天。我们都曾经看到自己的烂程序居然能运行,然后断言能运行的烂程序总比什么都没有强。我们都曾经说过有朝一日再回头清理。当然,在那些日子里,我们都没听过勒布朗(LeBlanc)法则:稍后等于永不 (Later equals never),</p></li><li><h4 id="混乱的代价"><a href="#混乱的代价" class="headerlink" title="混乱的代价"></a>混乱的代价</h4><p>  如果代码非常混乱，各种抽象关系、层级依赖关系、调用链混乱，终将导致后期的维护和迭代工作举步维艰。</p><p>  对代码的每次修改都影响到其他两三处代码。修改无小事。每次添加或修改代码,都得对那堆扭纹柴了然于心,这样才能往上扔更多的扭纹柴。这团乱麻越来越大,再也无法理清,最后束手无策。</p><p>  随着混乱的增加,团队生产力也持续下降,趋向于零。当生产力下降时,管理层就只有一独事可做了:增加更多人手到项目中,期望提升生产力。可是新人并不熟悉系统的设计。他们搞不清楚什么样的修改符合设计意图,什么样的修改违背设计意图。而且,他们以及团队中的其他人都背负着提升生产力的可怕压力。于是,他们制造更多的混乱,驱动生产力向零那端不断下降。</p></li><li><h4 id="整洁代码的艺术"><a href="#整洁代码的艺术" class="headerlink" title="整洁代码的艺术"></a>整洁代码的艺术</h4><p>  假设你相信混乱的代码是祸首,假设你接受做得快的唯一方法是保持代码整洁的说法,你一定会自问: “我怎么才能写出整洁的代码? ”不过,如果你不明白整洁对代码有何意义,尝试去写整洁代码就毫无所益!</p><p>  坏消息是写整洁代码很像是绘画。多数人都知道一幅画是好还是坏。但能分辨优劣并不表示懂得绘画。能分辨整洁代码和肮脏代码,也不意味着会写整洁代码!</p><p>  写整洁代码,需要遵循大量的小技巧,贯彻刻苦习得的“整洁感”。这种“代码感”就关键所在。有些人生而有之。有些人费点劲才能得到。它不仅让我们看到代码的优劣,还我们以借戒规之力化劣为优的攻略。</p><p>  缺乏“代码感”的程序员,看混乱是混乱,无处着手。有“代码感”的程序员能从混中看出其他的可能与变化。“代码感”帮助程序员选出最好的方案,并指导程序员制订修改行动计划,按图索骥。</p><p>  简言之,编写整洁代码的程序员就像是艺术家,他能用一系列变换把一块白板变作由优雅代码构成的系统。</p></li><li><h4 id="什么是整洁代码"><a href="#什么是整洁代码" class="headerlink" title="什么是整洁代码"></a>什么是整洁代码</h4><p>  <strong>有多少程序员，就有多少定义。</strong></p><p>  文章截取了多位知名且经验丰富的程序员的描述。</p><blockquote><p>Bjarne Stroustrup, C++语言发明者, C++ ProgrammingLanguage (中译版《C++程序设计语言》)一书作者。</p><p><code>&quot;我喜欢优雅和高效的代码。代码逻辑应当直截了当,叫缺陷难以隐藏;尽量减少依赖关系,使之便于维护;依据某种分层战略完善错误处理代码;性能调至最优,省得引诱别人做没规矩的优化,搞出一堆混乱来。整洁的代码只做好一件事。&quot;</code></p></blockquote><blockquote><p>  Grady Booch, Object Oriented Analysis and Design with Applications (中译版《面向对象分析与设计》)一书作者。</p><p>  <code>  &quot;整洁的代码简单直接。整洁的代码如同优美的散文。整洁的代码从不隐藏设计者的意图,充满了干净利落的抽象和直截了当的控制语句。&quot;</code></p></blockquote><blockquote><p>“老大” Dave Thomas, OTI公司创始人, Eclipse战略</p><p><code>&quot;整洁的代码应可由作者之外的开发者阅读和增补。它应有单元测试和验收测试。它使用有意义的命名。它只提供一种而非多种做一件事的途径。它只有尽量少的依赖关系,要明确地定义和提供清晰、尽量少的API.代码应通过其表达含义,因为不同的语言导致并非所有必需信息均可代码自身清晰表达。&quot;</code></p></blockquote><blockquote><p>Michael Feathers, Working Effectively with LegacyCode (中译版《修改代码的艺术》)一书作者。</p><p><code>&quot;我可以列出我留意到的整洁代码的所有特点,但其中有一条是根本性的。整洁的代码总是看起来像是某位特别在意它的人写的。几乎没有改进的余地。代码作者什么都想到了,如果你企图改进它,总会回到原点,赞叹某人留给你的代码一全心投入的某人留下的代码。&quot;</code></p></blockquote><blockquote><p>Ron Jeffries, Extreme Programming Installed (中译版《极限编程实施》)以及Extreme ProgrammingAdventures in C# (中译版《C#极限编程探险》)作者。</p><p>​    Ron初入行就在战略空军司令部(Strategic AirCommand)编写Fortran程序,此后几乎在每种机器上编写过每种语言的代码。他的言论值得咀嚼。</p><p>“近年来,我开始研究贝克的简单代码规则,差不多也都琢磨透了。简单代码,依其重要顺序:</p><p> 1.能通过所有测试;<br> 2.没有重复代码;<br> 3.体现系统中的全部设计理念;<br> 4.包括尽量少的实体,比如类、方法、函数等。<br>   在以上诸项中,我最在意代码重复。如果同一段代码反复出现,就表示某种想法未在代码中得到良好的体现。我尽力去找出到底那是什么,然后再尽力更清晰地表达出来。<br>   在我看来,有意义的命名是体现表达力的一种方式,我往往会修改好几次才会定下名字来。借助Eclipse这样的现代编码工具,重命名代价极低,所以我无所顾忌。然而,表达力还不只体现在命名上。我也会检查对象或方法是否想做的事太多。如果对象功能太多,最好是切分为两个或多个对象。如果方法功能太多,我总是使用抽取手段(Extract Method )重构之,从而得到一个能较为清晰地说明自身功能的方法,以及另外数个说明如何实现这些功能的方法。<br>   消除重复和提高表达力让我在整洁代码方面获益良多,只要铭记这两点,改进脏代码时就会大有不同。不过,我时常关注的另一规则就不太好解释了<br>   这么多年下来,我发现所有程序都由极为相似的元素构成。例如“在集合中查找某物”不管是雇员记录数据库还是名-值对哈希表,或者某类条目的数组,我们都会发现自己想要从集合中找到某一特定条目。一旦出现这种情况,我通常会把实现手段封装到更抽象的方法或类中。这样做好处多多。<br>   可以先用某种简单的手段,比如哈希表来实现这一功能, 由于对搜索功能的引用指向了我那个小小的抽象,就能随需应变,修改实现手段。这样就既能快速前进,又能为未来的修改预留余地。<br>   另外,该集合抽象常常提醒我留意“真正”在发生的事,避免随意实现集合行为,因为我真正需要的不过是某种简单的查找手段。<br>   减少重复代码,提高表达力,提早构建简单抽象。这就是我写整洁代码的方法。”</p></blockquote><blockquote><p>Ward Cunningham, Wiki发明者, eXtreme Programming(极限编程)的创始人之一, Smalitalk语言和面向对象的思想领袖。所有在意代码者的教父。</p><p><code>&quot;如果每个例程都让你感到深合己意,那就是整洁代码。如果代码让编程语言看起来像是专为解决那个问题而存在,就可以称之为漂亮的代码。&quot;</code></p></blockquote></li><li><h4 id="我们是作者"><a href="#我们是作者" class="headerlink" title="我们是作者"></a>我们是作者</h4><p>  Javadoc中的@author字段告诉我们自己是什么人。我们是作者。作者都有读者。实际上,作者有责任与读者做良好沟通。下次你写代码的时候,记得自己是作者,要为评判你工作的读者写代码。</p><p>  你或许会问:代码真正“读”的成分有多少呢?难道力量主要不是用在“写”上吗?</p><p>  你是否玩过“编辑器回放” ? 20世纪80、90年代, Emac之类编辑器记录每次击键动作。</p><p>  你可以在一小时工作之后,回放击键过程,就像是看一部高速电影。我这么做过,结果很有趣。</p><p>  回放过程显示,多数时间都是在滚动屏幕、浏览其他模块!</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">鲍勃进入模块。</span><br><span class="line">他向下滚动到要修改的函数。</span><br><span class="line">他停下来考虑可以做什么。</span><br><span class="line">哦,他滚动到模块顶端,检查变量初始化。</span><br><span class="line">现在他回到修改处,开始键入。</span><br><span class="line">喔，他删掉了键入的内容。</span><br><span class="line">他重新键入他又删除了!</span><br><span class="line">他键入了一半什么东西，又删除掉。</span><br><span class="line">他滚动到调用要修改函数的另一函数,看看是怎么调用的。</span><br><span class="line">他回到修改处,重新键入刚才删掉的代码。</span><br><span class="line">他停下来。</span><br><span class="line">他再一次删掉代码!</span><br><span class="line">他打开另一个窗口,查看别的子类。那是个复载函数吗?</span><br></pre></td></tr></table></figure><p>  <strong>你该明白了。读与写花费时间的比例超过10:1,写新代码时,我们一直在读旧代码。</strong></p><p>  既然比例如此之高,我们就想让读的过程变得轻松,即便那会使得编写过程更难。没可能光写不读,所以使之易读实际也使之易写。</p><p>  这事概无例外。不读周边代码的话就没法写代码。编写代码的难度,取决于读周边代码的难度。要想干得快,要想早点做完,要想轻松写代码,先让代码易读吧。</p></li><li><h4 id="童子军军规"><a href="#童子军军规" class="headerlink" title="童子军军规"></a>童子军军规</h4><p>  <strong>“让营地比你来时更干净。”</strong></p><p>  换成本书的意思就是，必须时刻保持代码整洁。让代码变得整洁并不是一蹴而就的事情，而是一个漫长的过程，每一次代码的提交都是使代码变整洁的一小步。</p></li></ul><h3 id="第2章-有意义的命名"><a href="#第2章-有意义的命名" class="headerlink" title="第2章 有意义的命名"></a>第2章 有意义的命名</h3><blockquote><p>  软件中随处可见命名。我们给变量、函数、参数、类和封包命名。我们给源代码及源代码所在目录命名。我们给jar文件、war文件和ear文件命名。我们命名、命名,不断命名。</p><p>  既然有这么多命名要做,不妨做好它。下文列出了取个好名字的几条简单规则。</p></blockquote><ul><li><h4 id="名副其实"><a href="#名副其实" class="headerlink" title="名副其实"></a>名副其实</h4><p>  名副其实说起来简单。我们想要强调,这事很严肃。选个好名字要花时间,但省下来的时间比花掉的多。注意命名,而且一旦发现有更好的名称,就换掉旧的。这么做,读你代码的人(包括你自己)都会更开心。</p><p>  变量、函数或类的名称应该已经答复了所有的大问题。它该告诉你,它为什么会存在,它做什么事,应该怎么用。如果名称需要注释来补充,那就不算是名副其实。</p><p>  例:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d; <span class="comment">// 消逝的时间,以日计</span></span><br></pre></td></tr></table></figure><p>  名称d什么也没说明。它没有引起对时间消逝的感觉,更别说以日计了。我们应该选择指明了计量对象和计量单位的名称:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> elapsedTimeInDays;</span><br><span class="line"><span class="keyword">int</span> daysSincecreation;</span><br><span class="line"><span class="keyword">int</span> dayssinceModification;</span><br><span class="line"><span class="keyword">int</span> fileAgeInDays;</span><br></pre></td></tr></table></figure><p>  例:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;<span class="keyword">int</span> []&gt; getThem() t</span><br><span class="line">List&lt;<span class="keyword">int</span>[]&gt; list1 =<span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] x: theList) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x[<span class="number">0</span>] =<span class="number">4</span>)</span><br><span class="line">    list1.add (x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> list1;</span><br></pre></td></tr></table></figure><p>  为什么难以说明上列代码要做什么事?里面并没有复杂的表达式。空格和缩进中规中矩。</p><p>  只用到三个变量和两个常量。甚至没有涉及任何其他类或多态方法,只是(或者看起来是)一个数组的列表而已。</p><p>  问题不在于代码的简洁度,而是在于代码的模糊度:即上下文在代码中未被明确体现的程度。上列代码要求我们了解类似以下问题的答案:</p><p>  (1) thelList中是什么类型的东西?</p><p>  (2) thelist零下标条目的意义是什么?</p><p>  (3)值4的意义是什么?</p><p>  (4)我怎么使用返回的列表?</p><p>  问题的答案没体现在代码段中,可那就是它们该在的地方。比方说,我们在开发一种扫雷游戏,我们发现,盘面是名为theList的单元格列表,那就将其名称改为gameBoard.</p><p>  ​    盘面上每个单元格都用一个简单数组表示。我们还发现,零下标条目是一种状态值,而该种状态值为4表示“已标记”,只要改为有意义的名称,代码就会得到相当程度的改进:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; getFlaggedCells()</span><br><span class="line">List&lt;<span class="keyword">int</span>[]&gt; flaggedCells = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> [] cell : gameBoard)&#123;</span><br><span class="line"><span class="keyword">if</span> (cell [STATUS_VALUE] FLAGGED)</span><br><span class="line">  flaggedCells.add (cell);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flaggedCells;</span><br></pre></td></tr></table></figure><p>  还可以更进一步,不用int数组表示单元格,而是另写一个类。该类包括一个名副其实的函数(称为isFlagged),从而掩盖住那个魔术数。于是得到函数的新版本:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Cell&gt; <span class="title">getFlaggedCells</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> List&lt;Cell&gt; flaggedCells = <span class="keyword">new</span> ArrayList&lt;Cell&gt;();</span><br><span class="line"><span class="keyword">for</span> (Cell cell : gameBoard) &#123;</span><br><span class="line">  <span class="keyword">if</span> (cell.isFlagged ()) </span><br><span class="line">    flaggedCells.add (cell);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flaggedcells; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  只要简单改一下名称,就能轻易知道发生了什么。这就是选用好名称的力量。</p></li><li><h4 id="避免误导"><a href="#避免误导" class="headerlink" title="避免误导"></a>避免误导</h4><p>  避免歧义，不能命名的过于模糊，有很多歧义。</p></li><li><h4 id="做有意义的区分"><a href="#做有意义的区分" class="headerlink" title="做有意义的区分"></a>做有意义的区分</h4><p>  类似于这样 命名为 a1 a2</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyChars</span><span class="params">(<span class="keyword">char</span> al[], <span class="keyword">char</span> a2[])</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; al.length; i++) &#123;</span><br><span class="line">a2 [i] =a1 [i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] a1;</span><br><span class="line">  <span class="keyword">int</span>[] a2;</span><br><span class="line">  copyChars(a1,a2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在调用方来看 无法分辨a1和a2的区别。</p><p>  如果参数名改为source和destination，这个函数就会像样许多。</p></li><li><h4 id="使用可搜索的名称"><a href="#使用可搜索的名称" class="headerlink" title="使用可搜索的名称"></a>使用可搜索的名称</h4><p>  单字母名称和数字常量有个问题,就是很难在一大篇文字中找出来。</p><p>  找MAXCLASSES PER STUDENT很容易,但想找数字7就麻烦了,它可能是某些文件名或其他常量定义的一部分,出现在因不同意图而采用的各种表达式中。如果该常量是个长数字,又被人错改过,就会逃过搜索,从而造成错误。</p><p>  同样, e也不是个便于搜索的好变量名。它是英文中最常用的字母,在每个程序、每段代码中都有可能出现。由此而见,长名称胜于短名称,搜得到的名称胜于用自造编码代写就的名称。</p><p>  切以为单字母名称仅用于短方法中的本地变量。名称长短应与其作用域大小相对应。若变量或常量可能在代码中多处使用,则应赋其以便于搜索的名称。</p><p>  例:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> X = <span class="number">80</span>;</span><br><span class="line"><span class="comment">// 对比</span></span><br><span class="line"><span class="keyword">int</span> X_SCALE_MAX_SIZE = <span class="number">80</span>;</span><br></pre></td></tr></table></figure></li><li><h4 id="避免使用编码"><a href="#避免使用编码" class="headerlink" title="避免使用编码"></a>避免使用编码</h4><p>  编码已经太多,无谓再自找麻烦。把类型或作用域编进名称里面,徒然增加了解码的负担。没理由要求每位新人都在弄清要应付的代码之外(那算是正常的),还要再搞懂另一种编码“语言”。这对于解决问题而言,纯属多余的负担。带编码的名称通常也不便发音,容易打错。</p></li><li><h4 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h4><p>  类名和对象名应该是名词或名词短语,如Customer、 WikiPage、 Account和AddressParser。</p><p>  避免使用Manager, Processor, Data或Info这样的类名。类名不应当是动词。</p></li><li><h4 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h4><p>  方法名应当是动词或动词短语,如postPayment, deletePage或save.属性访问器、修改器和断言应该根据其值命名,并依Javabean标准加上get, set和is前缀。</p></li><li><h4 id="每个概念对应一个词"><a href="#每个概念对应一个词" class="headerlink" title="每个概念对应一个词"></a>每个概念对应一个词</h4><p>  给每个抽象概念选一个词,并且一以贯之。例如,使用fetch, retrieve和get来给在多个类中的同种方法命名。你怎么记得住哪个类中是哪个方法呢?很悲哀,你总得记住编写库或类的公司、机构或个人,才能想得起来用的是哪个术语。否则,就得耗费大把时间浏览各个文件头及前面的代码。</p><p>  Eclipse和Intelli)之类现代编程环境提供了与环境相关的线索,比如某个对象能调用的方法列表。不过要注意,列表中通常不会给出你为函数名和参数列表编写的注释。如果参数名称来自函数声明,你就太幸运了。函数名称应当独一无二,而且要保持一致,这样你才能不借助多余的浏览就找到正确的方法。</p><p>  同样,在同一堆代码中有controller,又有manager,还有driver,就会令人困惑。DeviceManager和Protocol-Controller之间有何根本区别?为什么不全用controllers或managers?他们都是Drivers吗?这种名称,让人觉得这两个对象是不同类型的,也分属不同的类。</p><p>  对于那些会用到你代码的程序员,一以贯之的命名法简直就是天降福音</p></li><li><h4 id="使用解决方案领域名称"><a href="#使用解决方案领域名称" class="headerlink" title="使用解决方案领域名称"></a>使用解决方案领域名称</h4><p>  记住,只有程序员才会读你的代码。所以,尽管用那些计算机科学(Computer Science, CS)术语、算法名、模式名、数学术语吧。依据问题所涉领域来命名可不算是聪明的做法,因为不该让协作者老是跑去问客户每个名称的含义,其实他们早该通过另一名称了解这个概念了。</p><p>  对于熟悉访问者(VISITOR)模式的程序来说,名称AccountVisitor富有意义。哪个程序员会不知道JobQueue的意思呢?程序员要做太多技术性工作。给这些事取个技术性的名称,通常是最靠谱的做法。</p></li><li><h4 id="使用源自所涉问题领域的名称"><a href="#使用源自所涉问题领域的名称" class="headerlink" title="使用源自所涉问题领域的名称"></a>使用源自所涉问题领域的名称</h4><p>  如果不能用程序员熟悉的术语来给手头的工作命名,就采用从所涉问题领域而来的名称吧。至少,负责维护代码的程序员就能去请教领域专家了。</p><p>  优秀的程序员和设计师,其工作之一就是分离解决方案领域和问题领域的概念。与所涉问题领域更为贴近的代码,应当采用源自问题领域的名称。</p></li><li><h4 id="添加有意义的语境"><a href="#添加有意义的语境" class="headerlink" title="添加有意义的语境"></a>添加有意义的语境</h4><p>  很少有名称是能自我说明的-多数都不能。反之,你需要用有良好命名的类、函数或名称空间来放置名称,给读者提供语境。如果没这么做,给名称添加前缀就是最后一招了。</p><p>  设想你有名为firstName, lastName, street. houseNumber, city, state和zipcode的变量。</p><p>  当它们一块儿的时候,很明确是构成了一个地址。不过,假使只是在某个方法中看见孤零零一个state变量呢?你会理所当然推断那是某个地址的一部分吗?</p><p>  可以添加前缀addrFirstName, addrLastName, addrState等,以此提供语境。至少,读者会明白这些变量是某个更大结构的一部分。当然,更好的方案是创建名为Address的类。这样,即便是编译器也会知道这些变量隶属某个更大的概念了。</p></li><li><h4 id="不要添加没用的语境"><a href="#不要添加没用的语境" class="headerlink" title="不要添加没用的语境"></a>不要添加没用的语境</h4><p>  设若有一个名为“加油站豪华版” (Gas Station Deluxe)的应用,在其中给每个类添加GSD前缀就不是什么好点子。说白了,你是在和自己在用的工具过不去。输入G,按下自动完成键,结果会得到系统中全部类的列表,列表恨不得有一英里那么长。这样做聪明吗?为什么要搞得IDE没法帮助你?</p><p>  再比如,你在GSD应用程序中的记账模块创建了一个表示邮件地址的类,然后给该类命名为GSDAccountAddress.。稍后,你的客户联络应用中需要用到邮件地址,你会用GSDAccountAddress吗?这名字听起来没问题吗?在这17个字母里面,有10个字母纯属多余和与当前语境毫无关联。</p><p>  只要短名称足够清楚,就要比长名称好。别给名称添加不必要的语境。</p><p>  对于Address类的实体来说, accountAddress和customerAddress都是不错的名称,不过用在类名上就不太好了。Address是个好类名。如果需要与MAC地址、端口地址和Web地址相区别,我会考虑使用PostalAddress、 MAC和URI。这样的名称更为精确,而精确正是命名的要点。</p></li><li><h4 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h4><p>  取好名字最难的地方在于需要良好的描述技巧和共有文化背景。与其说这是一种技术、商业或管理问题,还不如说是一种教学问题。其结果是,这个领域内的许多人都没能学会做得很好。</p><p>  我们有时会怕其他开发者反对重命名。如果讨论一下就知道,如果名称改得更好,那大家真的会感激你。多数时候我们并不记忆类名和方法名。我们使用现代工具对付这些细节,好让自己集中精力于把代码写得就像词句篇章、至少像是表和数据结构(词句并非总是呈现数据的最佳手段)。改名可能会让某人吃惊,就像你做到其他代码改善工作一样。别让这种事阻碍你的前进步伐。</p><p>  不妨试试上面这些规则,看你的代码可读性是否有所提升。如果你是在维护别人写的代码,使用重构工具来解决问题。效果立竿见影,而且会持续下去。</p></li></ul><h3 id="第3章-函数"><a href="#第3章-函数" class="headerlink" title="第3章 函数"></a>第3章 函数</h3><blockquote><p>  在编程的早年岁月,系统由程序和子程序组成。后来,在Forran和PL/1的年代,系统由程序、子程序和函数组成。如今,只有函数存活下来。函数是所有程序中的第一组代码。</p><p>  本章将讨论如何写好函数。</p></blockquote><ul><li><h4 id="短小"><a href="#短小" class="headerlink" title="短小"></a>短小</h4><p>  函数的第一规则是要短小。第二条规则是还要更短小。</p><p>  在20世纪80年代,我们常说函数不该长于一屏。当然,说话时候, VT100屏幕只有24行、80列,而编辑器就得先占去4行空间放菜单。如今,用上了精致的字体和宽大的显示器,一屏里面可以显示100行,每行能容纳150个字符。每行都不应该有150个字符那么长。函数也不该有100行那么长, 20行封顶最佳。</p><p>  函数到底该有多长? 1991年,我去Kent Beck位于奥勒冈州(Oregon)的家中拜访。我们坐到一起写了些代码。他给我看一个叫做Sparkle (火花闪耀)的有趣的Java/Swing小程序。程序在屏幕上描画电影Cinderella (《灰姑娘》)中仙女用魔棒造出的那种视觉效果。只要移动鼠标,光标所在处就会爆发出一团令人欣喜的火花,沿着模拟重力场划落到窗口底部。肯特给我看代码的时候,我惊讶于其中那些函数尺寸之小。我看惯了Swing程序中长度数以里计的函数。但这个程序中每个函数都只有两行、三行或四行长。每个函数都一目了然。每个函数都只说一件事。而且,每个函数都依序把你带到下一个函数。这就是函数应该达到的短小程度!</p></li><li><h4 id="只做一件事"><a href="#只做一件事" class="headerlink" title="只做一件事"></a>只做一件事</h4><p>  这也是程序设计的一个重要思想，减少重复每个函数都尽可能的只处理一项任务。</p><p>  例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原版</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cookAndEatBreakFase</span><span class="params">(People people)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 去厨房</span></span><br><span class="line">  people.gotoKitchen();</span><br><span class="line">  <span class="comment">// 去冰箱拿鸡蛋</span></span><br><span class="line">  List&lt;Egg&gt; eggs = people.gotoRefrigerator().getEggs();</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 做早餐</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 带着早饭去餐桌</span></span><br><span class="line">  people.gotoDiningTableWidth(breakfast);</span><br><span class="line">   <span class="comment">// 吃早餐</span></span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cookAndEatBreakFase</span><span class="params">(Breakfast people)</span></span>&#123;</span><br><span class="line">  Breakfast breakfast = people.cookBreakfast();</span><br><span class="line">  people.eat(breakfast);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="每个函数一个抽象层级"><a href="#每个函数一个抽象层级" class="headerlink" title="每个函数一个抽象层级"></a>每个函数一个抽象层级</h4><p>  要确保函数只做一件事,函数中的语句都要在同一抽象层级上。一眼就能看出，上面原版的代码中不在一个抽象层级中。</p><p>  函数中混杂不同抽象层级,往往让人迷惑。读者可能无法判断某个表达式是基础概念还是细节。更恶劣的是,就像破损的窗户,一旦细节与基础概念混杂,更多的细节就会在函数中纠结起来。</p><p>  自顶向下读代码:向下规则</p><p>  我们想要让代码拥有自顶向下的阅读顺序。’我们想要让每个函数后面都跟着位于下一抽象层级的函数,这样一来,在查看函数列表时,就能循抽象层级向下阅读了。我把这叫做向下规则。</p></li><li><h4 id="使用描述性的名称"><a href="#使用描述性的名称" class="headerlink" title="使用描述性的名称"></a>使用描述性的名称</h4><p>  要确保能够从看到函数的名称能猜出大概做了什么事情。</p></li><li><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><p>  最理想的参数数量是零(零参数函数),其次是一(单参数函数),再次是二(双参数函数),应尽量避免三(三参数函数),有足够特殊的理由才能用三个以上参数(多参数函数)-所以无论如何也不要这么做。</p><p>  如果有多个参数，从两个方面尝试修改代码。</p><ol><li> 代码逻辑</li><li> 将代码参数有关联的抽象封装起来</li></ol><p>  例:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Circle <span class="title">makecircle</span> <span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> radius)</span></span>;</span><br><span class="line"><span class="function">circle <span class="title">makecircle</span> <span class="params">(Point center, <span class="keyword">double</span> radius)</span></span>;</span><br></pre></td></tr></table></figure></li><li><h4 id="标识参数"><a href="#标识参数" class="headerlink" title="标识参数"></a>标识参数</h4><p>  标识参数丑陋不堪。向函数传入布尔值简直就是骇人听闻的做法。这样做，方法签名立刻变得复杂起来，大声宣布本函数不止做一件事。如果标识为true将会这样做，标识为false则会那样做。</p><p>  应当拆分方法。使其相互独立。</p></li><li><h4 id="无副作用"><a href="#无副作用" class="headerlink" title="无副作用"></a>无副作用</h4><p>  副作用是一种谎言。函数承诺只做一件事,但还是会做其他被藏起来的事。有时,它会对自己类中的变量做出未能预期的改动。有时,它会把变量搞成向函数传递的参数或是系统全局变量。无论哪种情况,都是具有破坏性的,会导致古怪的时序性耦合及顺序依赖。</p></li><li><h4 id="使用异常替代返回错误码"><a href="#使用异常替代返回错误码" class="headerlink" title="使用异常替代返回错误码"></a>使用异常替代返回错误码</h4><p>  从指令式函数返回错误码轻微违反了指令与询问分隔的规则。它鼓励了在if语句判断中把指令当作表达式使用。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (deletePage (page) == E_OK)</span><br></pre></td></tr></table></figure><p>  这不会引起动词/形容词混淆,但却导致更深层次的嵌套结构。当返回错误码时,就是在要求调用者立刻处理错误。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (deletePage (page) == E_OK) &#123;</span><br><span class="line"><span class="keyword">if</span> (registry.deleteReference (page. name) ==E_OK)&#123;</span><br><span class="line">  <span class="keyword">if</span> (configkeys.deleteKey(page.name.makekey ()) ==E_OK)&#123;</span><br><span class="line">       logger.log (<span class="string">&quot;page deleted&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      logger.log (<span class="string">&quot;configKey not deleted&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">logger.loq (<span class="string">&quot;deleteReference from registry failed&quot;</span>);    </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  logger.log (<span class="string">&quot;delete failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  另一方面,如果使用异常替代返回错误码,错误处理代码就能从主路径代码中分离出来,得到简化:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  deletePage (page);</span><br><span class="line">registry.deleteReference (page.name);</span><br><span class="line">configKeys.deleteKey (page.name.makeKey ());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">logger.log(e.getMessage ());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h4 id="抽离TyCatch代码块"><a href="#抽离TyCatch代码块" class="headerlink" title="抽离TyCatch代码块"></a>抽离TyCatch代码块</h4><p>  Try/catch代码块丑陋不堪。它们搞乱了代码结构,把错误处理与正常流程混为一谈。最好把try和catch代码块的主体部分抽离出来,另外形成函数。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span> <span class="params">(Page page)</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    deletePageAndAl1References(page);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">      logError(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deletePageAndAl1References</span> <span class="params">(Page page)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  deletePage (page);</span><br><span class="line">registry.deleteReference (page. name);</span><br><span class="line">configKeys.deleteKey (page.name.makekey (<span class="number">1</span>) );</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h4 id="错误处理就是一件事"><a href="#错误处理就是一件事" class="headerlink" title="错误处理就是一件事"></a>错误处理就是一件事</h4><p>  函数应该只做一件事。错误处理就是一件事。因此,处理错误的函数不该做其他事。这意味着(如上例所示)如果关键字try在某个函数中存在,它就该是这个函数的第一个单词,而且在catch/finally代码块后面也不该有其他内容。</p></li><li><h4 id="Error-java依赖磁铁"><a href="#Error-java依赖磁铁" class="headerlink" title="Error.java依赖磁铁"></a>Error.java依赖磁铁</h4><p>  返回错误码通常暗示某处有个类或是枚举,定义了所有错误码。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Error</span> </span>&#123;</span><br><span class="line">Oк,</span><br><span class="line">INVALID,</span><br><span class="line">NO_SUCH,</span><br><span class="line">LOCKED,</span><br><span class="line">OUT_OF-RESOURCES,</span><br><span class="line">WAITING_FOR EVENT;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  这样的类就是一块依赖磁铁(dependency magnet);其他许多类都得导入和使用它。当Error枚举修改时,所有这些其他的类都需要重新编译和部署。这对Error类造成了负面压力。</p><p>  程序员不愿增加新的错误代码,因为这样他们就得重新构建和部署所有东西。于是他们就复用旧的错误码,而不添加新的。</p><p>  使用异常替代错误码,新异常就可以从异常类派生出来,无需重新编译或重新部署。</p><p>  定义新的Exception。</p></li><li><h4 id="别重复自己"><a href="#别重复自己" class="headerlink" title="别重复自己"></a>别重复自己</h4><p>  不要重复自己的函数。</p><p>  这样的重复还是会导致问题,因为代码因此而臃肿,且当算法改变时需要修改4处地方。而且也会增加4次放过错误的可能性。</p><p>  重复可能是软件中一切邪恶的根源。许多原则与实践规则都是为控制与消除重复而创建,例如,全部考德(Codd) ,数据库范式都是为消灭数据重复而服务。再想想看,面向对象编程是如何将代码集中到基类,从而避免了冗余。面向方面编程(Aspect Oriented Programming).</p><p>  面向组件编程(Component Oriented Programming)多少也都是消除重复的一种策略。看来,自子程序发明以来,软件开发领域的所有创新都是在不断尝试从源代码中消灭重复。</p></li><li><h4 id="结构化编程"><a href="#结构化编程" class="headerlink" title="结构化编程"></a>结构化编程</h4><p>  有些程序员遵循Edsger Dijkstra的结构化编程规则。 Djkstra认为,每个函数、函数中的每个代码块都应该有一个入口、一个出口。遵循这些规则,意味着在每个函数中只该有一个return语句,循环中不能有break或continue语句,而且永永远远不能有任何goto语句。</p><p>  我们赞成结构化编程的目标和规范,但对于小函数,这些规则助益不大。只有在大函数中,这些规则才会有明显的好处。</p><p>  所以,只要函数保持短小,偶尔出现的return、 break或continue语句没有坏处,甚至还比单入单出原则更具有表达力。另外一方面, goto只在大函数中才有道理,所以应该尽量避免使用。</p></li><li><h4 id="如何写出这样的函数"><a href="#如何写出这样的函数" class="headerlink" title="如何写出这样的函数"></a>如何写出这样的函数</h4><p>  写代码和写别的东西很像。在写论文或文章时,你先想什么就写什么,然后再打磨它。</p><p>  初稿也许粗陋无序,你就斟酌推敲,直至达到你心目中的样子。</p><p>  我写函数时,一开始都冗长而复杂。有太多缩进和嵌套循环。有过长的参数列表。名称是随意取的,也会有重复的代码。不过我会配上一套单元测试,覆盖每行丑陋的代码。</p><p>  然后我打磨这些代码,分解函数、修改名称、消除重复。我缩短和重新安置方法。有时我还拆散类。同时保持测试通过。</p><p>  最后,遵循本章列出的规则,我组装好这些函数。</p><p>  我并不从一开始就按照规则写函数。我想没人做得到。</p></li><li><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>  每个系统都是使用某种领域特定语言搭建,而这种语言是程序员设计来描述那个系统的。</p><p>  函数是语言的动词,类是名词。这并非是退回到那种认为需求文档中的名词和动词就是系统中类和函数的最初设想的可怕的旧观念。其实这是个历史更久的真理。编程艺术是且一直就是语言设计的艺术。</p><p>  大师级程序员把系统当作故事来讲,而不是当作程序来写。他们使用选定编程语言提供的工具构建一种更为丰富且更具表达力的语言,用来讲那个故事。那种领域特定语言的一个部分,就是描述在系统中发生的各种行为的函数层级。在一种狡猾的递归操作中,这些行为使用它们定义的与领域紧密相关的语言讲述自己那个小故事。</p><p>  本章所讲述的是有关编写良好函数的机制。如果你遵循这些规则,函数就会短小,有个好名字,而且被很好地归置。不过永远别忘记,真正的目标在于讲述系统的故事,而你编写的函数必须干净利落地拼装到一起,形成一种精确而清晰的语言,帮助你讲故事。</p></li></ul><h3 id="第4章-注释"><a href="#第4章-注释" class="headerlink" title="第4章 注释"></a>第4章 注释</h3><blockquote><p>  “别给糟糕的代码加注释-重新写吧。” </p><p>  ​                                                    –Brian W. Kernighan与P J. Plaugher</p></blockquote><ul><li><h4 id="能用函数或变量时就别用注释"><a href="#能用函数或变量时就别用注释" class="headerlink" title="能用函数或变量时就别用注释"></a>能用函数或变量时就别用注释</h4><p>  能够用函数名称或者变量名称能解释的事情，就不要使用注释。</p></li><li><h4 id="注释掉的代码"><a href="#注释掉的代码" class="headerlink" title="注释掉的代码"></a>注释掉的代码</h4><p>  直接把代码注释掉是讨厌的做法。别这么干!</p><p>  其他人不敢删除注释掉的代码。他们会想,代码依然放在那儿,一定有其原因,而且这段代码很重要,不能删除。</p><p>  注释掉的代码堆积在一起,就像破酒瓶底的渣滓一般。</p><p>  20世纪60年代,曾经有那么一段时间,注释掉的代码可能有用。但我们已经拥有优良的源代码控制系统如此之久,这些系统可以为我们记住不要的代码。我们无需再用注释来标记,删掉即可,它们丢不了。我担保。</p></li><li><h4 id="TODO注释"><a href="#TODO注释" class="headerlink" title="TODO注释"></a>TODO注释</h4><p>  TODO是一种程序员认为应该做,但由于某些原因目前还没做的工作。它可能是要提醒删除某个不必要的特性,或者要求他人注意某个问题。它可能是恳请别人取个好名字,或者提示对依赖于某个计划事件的修改。无论TODO的目的如何,它都不是在系统中留下糟糕的代码的借口。</p><p>  如今,大多数好IDE都提供了特别的手段来定位所有TODO注释,这些注释看来丢不了。</p><p>  你不会愿意代码因为TODO的存在而变成一堆垃圾,所以要定期查看,删除不再需要的。</p></li><li><h4 id="警示"><a href="#警示" class="headerlink" title="警示"></a>警示</h4>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> simpleDateFormat <span class="title">makestandardHttpDateFormat</span> <span class="params">()</span> 1</span></span><br><span class="line"><span class="function"><span class="comment">//simplaDateFormat is not thread safe,</span></span></span><br><span class="line"><span class="function"><span class="comment">//so ve need to create each instance independently.</span></span></span><br><span class="line"><span class="function">SimpleDateFormat df </span>= <span class="keyword">new</span> SimpleDateFormat (<span class="string">&quot;EEE, dd MMM yyyy HH:mm:ss z&quot;</span>);</span><br><span class="line">df. setTimeZone (TimeZone. getTimeZone (<span class="string">&quot;GMT&quot;</span>));</span><br><span class="line"><span class="keyword">return</span> df;</span><br></pre></td></tr></table></figure><p>  例上面的注释绝对有道理存在,它能阻止某位急切的程序员以效率之名使用静态初始器。</p></li><li><h4 id="对意图的解释"><a href="#对意图的解释" class="headerlink" title="对意图的解释"></a>对意图的解释</h4><p>  有时,注释不仅提供了有关实现的有用信息,而且还提供了某个决定后面的意图。在下例中,我们看到注释反映出来的一个有趣决定。在对比两个对象时,作者决定将他的类放置在比其他东西更高的位置。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(object o)</span></span></span><br><span class="line"><span class="function">  <span class="title">if</span> <span class="params">(o <span class="keyword">instanceof</span> wikiPagePath)</span></span>&#123;</span><br><span class="line">      WikiPagePath p= (wikiPagePath) o;</span><br><span class="line">      string compressedName = Stringutil.join(names, <span class="string">&quot;&quot;</span>);</span><br><span class="line">      string compressedArgumentName = stringUtil.join(p.names, <span class="string">&quot;&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> compressedName.compareTo(compressedArgumentName);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// we are greater because we are the right type.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h4 id="阐释"><a href="#阐释" class="headerlink" title="阐释"></a>阐释</h4><p>  有时,注释把某些晦涩难明的参数或返回值的意义翻译为某种可读形式,也会是有用的。</p><p>  通常,更好的方法是尽量让参数或返回值自身就足够清楚;但如果参数或返回值是某个标准库的一部分,或是你不能修改的代码,帮助阐释其含义的代码就会有用。</p></li></ul><h3 id="第5章-格式"><a href="#第5章-格式" class="headerlink" title="第5章 格式"></a>第5章 格式</h3><blockquote><p>  以前我最在意的一个细节，每行代码的长度限制、垂直分割行、每个方法之间间隔，这些细节我都会在写代码过程中带有强迫性质的进行修改。</p></blockquote><ul><li><h4 id="格式的目的"><a href="#格式的目的" class="headerlink" title="格式的目的"></a>格式的目的</h4><p>  增强可读性、连贯性、可维护性。</p></li><li><h4 id="垂直格式"><a href="#垂直格式" class="headerlink" title="垂直格式"></a>垂直格式</h4><p>  <strong>变量声明</strong>。变量声明应尽可能靠近其使用位置。因为函数很短，本地变量应该在函数的顶部出现，偶尔在函数较长时，变量也可以定义在某个代码块顶部。</p><p>  <strong>实体变量</strong>应该在类的顶部声明。这应该不会增加变量的垂直距离,因为在设计良好的类中,它们如果不是被该类的所有方法也是被大多数方法所用。</p><p>  <strong>相关函数</strong>。若某个函a数调用了另外一个,就应该把它们放到一起,而且调用者应该尽可能放在被调用者上面。这样,程序就有个自然的顺序。若坚定地遵循这条约定,读者将能够确信函数声明总会在其调用后很快出现。注意顶部的函数是如何调用其下的函数,而这些被调用的函数又是如何调用更下面的函数的。这样就能轻易找到被调用的函数,极大地增强了整个模块的可读性。</p><p>  <strong>概念相关</strong>。概念相关的<strong>代码</strong>应该放到一起。相关性越强,彼此之间的距离就该越短。</p><p>  如上所述,相关性应建立在直接依赖的基础上,如函数间调用,或函数使用某个变量。</p><p>  但也有其他相关性的可能。相关性可能来自于执行相似操作的一组函数。</p></li><li><h4 id="其他格式（缩进，导包，空范围，代码横向长度）"><a href="#其他格式（缩进，导包，空范围，代码横向长度）" class="headerlink" title="其他格式（缩进，导包，空范围，代码横向长度）"></a>其他格式（缩进，导包，空范围，代码横向长度）</h4><p>  可以依赖公司开发规范，或者参考Alibaba开发手册。</p></li></ul><h3 id="第6章-对象和数据结构"><a href="#第6章-对象和数据结构" class="headerlink" title="第6章 对象和数据结构"></a>第6章 对象和数据结构</h3><blockquote><p>  将变量设置为私有(private)有一个理由:我们不想其他人依赖这些变量。我们还想在心血来潮时能自由修改其类型或实现。那么,为什么还是有那么多程序员给对象自动添加赋值器和取值器,将私有变量公之于众、如同它们根本就是公共变量一般呢?</p></blockquote><ul><li><h4 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h4><p>  看看代码PointA和代码PointB之间的区别。每段代码都表示笛卡儿平面上的一个点。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PointA</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">double</span> x;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">double</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PointB</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">getX</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">getY</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setCartesian</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">getR</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">getTheta</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setPolar</span><span class="params">(<span class="keyword">double</span> r, <span class="keyword">double</span> theta)</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>  PointA曝露了其实现,而PointB则完全隐藏了其实现。</p><p>  PointB的漂亮之处在于,你不知道该实现会是在矩形坐标系中还是在极坐标系中。</p><p>  <strong>隐藏实现并非只是在变量之间放上一个函数层那么简单。隐藏实现关乎抽象!</strong></p><p>  <strong>类并不简单地用取值器和赋值器将其变量推向外间,而是曝露抽象接口,以便用户无需了解数据的实现就能操作数据本体。</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具象机动车</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getFuelTankCapacityInGallons</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getGallonsOfGasoline</span> <span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象机动车</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Vehicle</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getPercentFuelRemaining</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  以上两段代码以后者为佳。我们不愿曝露数据细节,更愿意以抽象形态表述数据。这并不只是用接口和/或赋值器、取值器就万事大吉。要以最好的方式呈现某个对象包含的数据，需要做严肃的思考。傻乐着乱加取值器和赋值器，是最坏的选择。</p></li><li><h4 id="数据对象的反对称性"><a href="#数据对象的反对称性" class="headerlink" title="数据对象的反对称性"></a>数据对象的反对称性</h4><p>  <strong>对象把数据隐藏于抽象之后，暴露操作数据的函数</strong></p><p>  <strong>数据结构暴露其数据，而没有提供有意义的函数</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此种形式为数据结构形式，暴露数据，没有函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> Point topLeft;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">double</span> side;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> Point topLeft;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">double</span> height;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">double</span> width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gemometry</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.141592653589793</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">(object shape)</span> <span class="keyword">throws</span> NoSunShapeException</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(shape <span class="keyword">instanceof</span> Square)&#123;</span><br><span class="line">      Square s = (Square)shape;</span><br><span class="line">      <span class="keyword">return</span> s.side*s.side;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(shape <span class="keyword">instanceof</span> Rectangle)&#123;</span><br><span class="line">      Rectangle r = (Rectangel) shape;</span><br><span class="line">      <span class="keyword">return</span> r.hegiht*r.width;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchShapeException();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此种方式为对象方式，隐藏了实现，提供方法（未暴露实现）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Point topLeft;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> side;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> side*side;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Point topLeft;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> height;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> width;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> height*width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Point center;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.141592653589793</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PI * radius * radius;        </span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li><p>数据结构的方法暴露了其本身的数据，但没有提供有意义的函数；<strong>面向过程</strong></p></li><li><p>数据结构可以方便的添加函数，但添加数据结构类型十分不便；</p></li><li><p>原因在于添加一个数据结构类型需要修改所有已经存在的函数；</p></li><li><p>对象的方法保护了其私有数据，提供抽象的方法；<strong>面向对象</strong></p></li><li><p>此方法可以方便的添加对象类型，应为每种类型是不相互干扰互相独立的；</p></li><li><p>但添加方法十分复杂，需要修改所有的对象类；</p></li></ul><p>  <code>过程式代码(使用数据结构的代码)便于在不改动既有数据结构的前提下添加新函数。</code></p><p>  <code>面向对象代码便于在不改动既有函数的前提下添加新类。</code></p><p>  反过来讲也说得通。</p><p>  <code>过程式代码难以添加新数据结构, 因为必须修改所有函数。</code></p><p>  <code>面向对象代码难以添加新函数,因为必须修改所有类。</code></p><p>  在任何一个复杂系统中,都会有需要添加新数据类型而不是新函数的时候。这时,对象和面向对象就比较适合。另一方面,也会有想要添加新函数而不是数据类型的时候。在这种情况下,过程式代码和数据结构更合适。</p></li><li><h4 id="得墨忒耳律"><a href="#得墨忒耳律" class="headerlink" title="得墨忒耳律"></a>得墨忒耳律</h4><p>  著名的得墨忒耳律(The Law of Demeter) 认为:</p><ul><li><p>模块不应了解它所操作对象的内部情形。</p></li><li><p>如上节所见,对象隐藏数据,曝露操作。这意味着对象不应通过存取器曝露其内部结构,因为这样更像是曝露而非隐藏其内部结构。</p></li></ul><p>  更准确地说，得墨忒耳律认为，类C的方法 f 只应该调用以下对象的方法：</p><ul><li><p>  C</p></li><li><p>  由 f 创建的对象；</p></li><li><p>  作为参数传递给 f 的对象；</p></li><li><p>  由 C 的实体变量持有的对象。</p></li></ul><p>  <strong>方法不应调用由任何函数返回的对象的方法。换言之,只跟朋友谈话,不与陌生人谈话。</strong></p><p>  下列代码违反了得墨忒耳律(除了违反其他规则之外),因为它调用了getOptions()返回值的getScratchDir()函数,又调用了getScratchDir()返回值的getAbsolutePath()方法。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> string outputDir =ctxt.getOptions ().getScratchDir() .getAbsolutePath ();</span><br></pre></td></tr></table></figure><p>  很多面向对象程序设计语言用”.”表示对象的域的解析算符，因此得墨忒耳定律可以简单地陈述为“只使用一个.算符”。因此，a.b.Method()违反了此定律，而a.Method()不违反此定律。</p><p>  <strong>一个简单例子是，人可以命令一条狗行走（walk），但是不应该直接指挥狗的腿行走，应该由狗去指挥控制它的腿如何行走。</strong></p></li><li><h4 id="数据传输对象"><a href="#数据传输对象" class="headerlink" title="数据传输对象"></a>数据传输对象</h4><p>  最为精炼的数据结构，是只有公共变量，没有函数的类；这种数据结构被称为数据传送对象，或DTO（Data Transfer Objects）</p></li><li><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>  对象曝露行为,隐藏数据。便于添加新对象类型而无需修改既有行为,同时也难以在既有对象中添加新行为。数据结构曝露数据,没有明显的行为。便于向既有数据结构添加新行为,同时也难以向既有函数添加新数据结构。</p><p>  在任何系统中,我们有时会希望能够灵活地添加新数据类型,所以更喜欢在这部分使用对象。另外一些时候,我们希望能灵活地添加新行为,这时我们更喜欢使用数据类型和过程。</p><p>  优秀的软件开发者不带成见地了解这种情形,并依据手边工作的性质选择其中一种手段。</p></li></ul><h3 id="第7章-错误处理"><a href="#第7章-错误处理" class="headerlink" title="第7章 错误处理"></a>第7章 错误处理</h3><blockquote><p>错误处理很重要，但它不应该搞乱代码的逻辑。</p></blockquote><ul><li><h4 id="使用异常而非返回码"><a href="#使用异常而非返回码" class="headerlink" title="使用异常而非返回码"></a>使用异常而非返回码</h4><p>使用返回码，自定义错误码、Null；这样的操作会使调用者在调用之后即刻检查错误，但此类操作容易被忽略，容易出现问题，且代码可读性较差，不美观。</p><p>使用抛出异常的方式，调用代码很整洁，其逻辑不会被错误处理搞乱。</p></li><li><h4 id="先写Try-Catch-Finaly"><a href="#先写Try-Catch-Finaly" class="headerlink" title="先写Try-Catch-Finaly"></a>先写Try-Catch-Finaly</h4><p>妙处之一是,它们在程序中定义了一个范围。执行try-catch-finally语句中try部分的代码时,你是在表明可随时取消执行,并在catch语句中接续。</p><p>在某种意义上, try代码块就像是事务。catch代码块将程序维持在一种持续状态,无论try代码块中发生了什么均如此。</p><p>在编写可能抛出异常的代码时，最好先写出ty-atch-finally语句，这能帮你定义代码的用户应该期待什么,无论try代码块中执行的代码出什么错都一样。</p></li><li><h4 id="使用不可控异常"><a href="#使用不可控异常" class="headerlink" title="使用不可控异常"></a>使用不可控异常</h4><p>以某个大型系统的调用层级为例。顶瑞函数调用它们之下的函数,逐级向下。假设某个位于最底层级的函数被修改为抛出一个异常。如果该异常是可控的,则函数签名就要添加throw子句。这意味着每个调用该函数的函数都要修改,捕获新异常,或在其签名中添加合适的throw子句。以此类推。最终得到的就是一个从软件最底端贯穿到最高端的修改链!封装被打破了,因为在抛出路径中的每个函数都要去了解下一层级的异常细节。既然异常旨在让你能在较远处处理错误,可控异常以这种方式破坏封装简直就是一种耻辱。</p><p>如果你在编写一套关键代码库,则可控异常有时也会有用:你必须捕获异常。但对于一般的应用开发,其依赖成本要高于收益。</p></li><li><h4 id="给出异常发生是的环境说明"><a href="#给出异常发生是的环境说明" class="headerlink" title="给出异常发生是的环境说明"></a>给出异常发生是的环境说明</h4><p>你抛出的每个异常,都应当提供足够的环境说明,以便判断错误的来源和处所。</p></li><li><h4 id="依调用者需要定义异常类"><a href="#依调用者需要定义异常类" class="headerlink" title="依调用者需要定义异常类"></a>依调用者需要定义异常类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">ACMEPort port = <span class="keyword">new</span> ACMEPort(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//该段代码中包含了较多的重复，并且由各种异常，对此可以对第三方API进行打包，使其返回相同的代码；</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  port.open();</span><br><span class="line">&#125;<span class="keyword">catch</span>(DeviceResponseException e)&#123;</span><br><span class="line">  reportPortError(e);</span><br><span class="line">  logger.log(<span class="string">&quot;Device response exception&quot;</span>,e);</span><br><span class="line">&#125;<span class="keyword">catch</span>(ATM1212UnlockedException e)&#123;</span><br><span class="line">  reportPortError(e);</span><br><span class="line">  logger.log(<span class="string">&quot;Unlock exception&quot;</span>,e);</span><br><span class="line">&#125;<span class="keyword">catch</span>(GMXError e)&#123;</span><br><span class="line">  reportPortError(e);</span><br><span class="line">  logger.log(<span class="string">&quot;Device response exception&quot;</span>,e);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下方法对第三方API进行了打包，同一了向上throw的异常类型</span></span><br><span class="line">LocalPort port = <span class="keyword">new</span> LocalPort(<span class="number">12</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  port.open()</span><br><span class="line">&#125;<span class="keyword">catch</span>(PortDeviceFailure e)&#123;</span><br><span class="line">  reportError(e);</span><br><span class="line">  logger.log(e.getMessage e);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalPort</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ACMEPort innerport;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LocalPort</span><span class="params">(<span class="keyword">int</span> portNumber)</span></span>&#123;</span><br><span class="line">    innerPort = <span class="keyword">new</span> ACMEPort(portNumber);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      innerPort.open();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(DeviceResponseException e)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> PortDeviceFailure(e);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(ATM1212UnlockExcetion e)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> PortDeviceFailure(e);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(GMXError e)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> PortDeviceFailure(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似我们为ACMEPort定义的这种打包类非常有用。实际上,将第三方API打包是个良好的实践手段。当你打包一个第三方API,你就降低了对它的依赖:未来你可以不太痛苦地改用其他代码库。在你测试自己的代码时,打包也有助于模拟第三方调用。</p></li><li><h4 id="定义常规流程"><a href="#定义常规流程" class="headerlink" title="定义常规流程"></a>定义常规流程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来看一个例子。下面的笨代码来自某个记账应用的开支总计模块:</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  MealExpense expenses = expenseReportDAO.getMeals(employee.getID());</span><br><span class="line">  m_total += expenses.getTotal();</span><br><span class="line">&#125;<span class="keyword">catch</span>(MealExpenseNotFound e)&#123; </span><br><span class="line">  m_total += getMealPerDiem();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务逻辑是,如果消耗了餐食,则计入总额中。如果没有消耗,则员工得到当日餐食补贴。异常打断了业务逻辑。如果不去处理特殊情况会不会好一些?那样的话代码看起来会更简洁。就像这样:</span></span><br><span class="line"></span><br><span class="line">MealExpensses expenses = expenseReportDAO.getMeals(employee.getID());</span><br><span class="line">m_total += expenses.getTotal();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 能把代码写得那样简洁吗?能。可以修改ExpenseReportDA ,使其总是返回MealExpense对象。如果没有餐食消耗,就返回一个返回餐食补贴的MealExpense对象。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerDiemMealExpense</span> <span class="keyword">implements</span> <span class="title">MealExpenses</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//retrun the per diem default</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种手法叫做特例模式(SPECIAL CASE PATTERN, [Fowlerj),创建一个类或配置一个对象,用来处理特例。你来处理特例,客户代码就不用应付异常行为了。异常行为被封装到特例对象中。</p></li><li><h4 id="别返回null值"><a href="#别返回null值" class="headerlink" title="别返回null值"></a>别返回null值</h4><p>每一处可能返回null值就要进行返回值检查，这样的检查使得代码凌乱；</p><p>对于返回null的函数最好可以返回特例，避免null判断；次之返回异常进行处理</p></li><li><h4 id="别传递null值"><a href="#别传递null值" class="headerlink" title="别传递null值"></a>别传递null值</h4><p>在方法中返回null值是糟糕的做法,但将null值传递给其他方法就更糟糕了。</p><p>除非API要求你向它传递null值,否则就要尽可能避免传递null值。</p></li><li><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>整洁代码是可读的,但也要强固。可读与强固并不冲突。如果将错误处理隔离看待,独立于主要逻辑就能写固而整洁的代码。做到这一步,我们就能单独处理它,也极大地提升了代码的可维护性。</p></li></ul><h3 id="第8章-边界"><a href="#第8章-边界" class="headerlink" title="第8章 边界"></a>第8章 边界</h3><ul><li><h4 id="使用第三方代码"><a href="#使用第三方代码" class="headerlink" title="使用第三方代码"></a>使用第三方代码</h4><p>在接口提供者和使用者之间,存在与生俱来的张力。第三方程序包和框架提供者追求普适性,这样就能在多个环境中工作,吸引广泛的用户。而使用者则想要集中满足特定需求的接口。</p><p>这种张力会导致系统边界上出现问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此方法将sensors暴露在外部，在函数间传递不安全</span></span><br><span class="line">Map sensors = <span class="keyword">new</span> HashMap();</span><br><span class="line">...</span><br><span class="line">Sensor s = (Sensor)sensors.get(sensorId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此种方法在使用Sensors时无需考虑其内部实现，避免了对sensors的无意修改；当HashMap修改时，对Sensors 的修改就在此类的内部，做到了很好的隔离</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sensors</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Map sensors = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Sensor <span class="title">getById</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (Sensor) sensors.get(id);</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的重构方法使<strong>HashMap</strong>的使用<strong>隔离</strong>在<strong>Sensors类的内部</strong>，当HashMap修改时，只需修改Sensors类一处，实现低耦合；</p></li><li><h4 id="整洁的边界"><a href="#整洁的边界" class="headerlink" title="整洁的边界"></a>整洁的边界</h4><p>边界会经常需要改动，良好的软件设计无需巨大的投入和重写即可修改；</p><p>在使用控制不了的代码（第三方库）时，需要加倍的小心，确保未来的修改代价不要太大；</p><p>避免代码过多的依赖第三方代码中特定的信息，<strong>依靠能控制的</strong>好过依靠控制不了的，避免日后受它控制；</p></li></ul><h3 id="第9章-单元测试"><a href="#第9章-单元测试" class="headerlink" title="第9章 单元测试"></a>第9章 单元测试</h3><ul><li><h4 id="TDD三定律"><a href="#TDD三定律" class="headerlink" title="TDD三定律"></a>TDD三定律</h4><p><strong>定律一：在编写不能通过的单元测试前，不可编写生产代码。</strong></p><p>测试驱动开发主张“测试先行”，这意味着我们必须先写单元测试，并且该单元测试必然失败，才能编写生产代码。</p><p><strong>定律二：只可编写刚好无法通过的单元测试，不能编译也算不通过。</strong><br>测试驱动开发鼓励“简单设计”，以很小的增量进行开发，遇到设计问题时能够及时解决，不要期望一个测试能实现多个功能。</p><p><strong>定律三：只可编写刚好通过当前失败测试的生产代码。</strong></p><p>简洁，尽最大可能减少不必要的工作，也是敏捷基本原则之一。要避免盲目编写将来有可能需要的代码。</p><p>遵循了测试驱动开发的这三条定律，那所有代码都是可测试的了。“可测试”的另一个词是“解耦”，为了单独测试模块，必须将其分离，所以测试驱动开发强迫分离模块，迫使大家创建更好、更少耦合的设计。</p></li><li><h4 id="保持测试整洁"><a href="#保持测试整洁" class="headerlink" title="保持测试整洁"></a>保持测试整洁</h4><p>测试代码需要跟着生产代码的修改而修改。</p><p>测试代码和生产代码一样重要，也需要被思考、被设计和被照料。</p></li><li><h4 id="整洁的测试"><a href="#整洁的测试" class="headerlink" title="整洁的测试"></a>整洁的测试</h4><p><strong>整洁的测试有什么要素？有三个要素：可读性、可读性和可读性。</strong><br><strong>测试代码要如何才能做到可读？和其他代码一样：明确、简洁还有足够的表达力。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样的测试代码可读性很差</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetPageHieratchyAsXml</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  crawler.addPage(root, PathParser.parse(<span class="string">&quot;PageOne&quot;</span>));</span><br><span class="line">  crawler.addPage(root, PathParser.parse(<span class="string">&quot;PageOne.ChildOne&quot;</span>));</span><br><span class="line">  crawler.addPage(root, PathParser.parse(<span class="string">&quot;PageTwo&quot;</span>));</span><br><span class="line">  request.setResource(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">  request.addInput(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;pages&quot;</span>);</span><br><span class="line">  Responder responder = <span class="keyword">new</span> SerializedPageResponder();</span><br><span class="line">  SimpleResponse response = (SimpleResponse) responder.makeResponse(<span class="keyword">new</span> FitNesseContext(root), request);</span><br><span class="line">  string xml = response.getContent();</span><br><span class="line">  assertEquals(<span class="string">&quot;text/xml&quot;</span>, response.getContentType());</span><br><span class="line">  assertSubstrinq(<span class="string">&quot;&lt;name&gt;PageOne&lt;/name&gt;&quot;</span>, xml);</span><br><span class="line">  assertSubstring(<span class="string">&quot;&lt;name&gt;PageTwo&lt;/name&gt;&quot;</span>, xml);</span><br><span class="line">  assertSubstring(<span class="string">&quot;&lt;name&gt;Childone&lt;/name&gt;&quot;</span>, xml);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应采用构造-操作-检验(BUILD-OPERATE-CHECK) 模式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetPageHierarchyAsXml</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">  <span class="comment">//build</span></span><br><span class="line">  makePages(<span class="string">&quot;PageOne&quot;</span>,<span class="string">&quot;PageOne.ChildOne&quot;</span>,<span class="string">&quot;PageTwo&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//operate</span></span><br><span class="line">  submitRequest(<span class="string">&quot;root&quot;</span>,<span class="string">&quot;type:pages&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//check</span></span><br><span class="line">  assertResponseIsXML();</span><br><span class="line">  assertResponseContains(<span class="string">&quot;&lt;name&gt;PageOne&lt;/name&gt;&quot;</span>,<span class="string">&quot;&lt;name&gt;PageTwo&lt;/name&gt;&quot;</span>,<span class="string">&quot;&lt;name&gt;ChildOne&lt;/name&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个测试显然呈现了构造-操作-检验(BUILD-OPERATE-CHECK) 模式。每个测试都清晰地拆分为三个环节。</p><p>第一个环节构造测试数据,</p><p>第二个环节操作测试数据,</p><p>第三个部分检验操作是否得到期望的结果。</p><p>注意,那些恼人的细节大部分消失了。测试直达目的,只用到那些真正需要的数据类型和函数。读测试的人应该都能够很快搞清楚状况,不至于被细节误导或吓倒。</p></li><li><h4 id="双重标准"><a href="#双重标准" class="headerlink" title="双重标准"></a>双重标准</h4><p>有些事情可能只会在测试代码中做，而生产代码中可能不会做；所以内存或者CPU的效率在测试代码中可以稍微妥协，以提高代码的可读性；</p></li><li><h4 id="测试每一个断言"><a href="#测试每一个断言" class="headerlink" title="测试每一个断言"></a>测试每一个断言</h4><p><strong>遵循given-when-then的约定；</strong></p><pre><code>given – some contextwhen – some actions is carried outthen – a particular set of consequences should obtain</code></pre><p><strong>这里所说的就是BUILD-OPERATE-CHECK</strong><br><strong>最佳规则也许是应该尽可能减少每个概念的断言数量,每个测试函数只测试一个概念。</strong></p></li><li><h4 id="F-I-R-S-T"><a href="#F-I-R-S-T" class="headerlink" title="F.I.R.S.T"></a>F.I.R.S.T</h4><p><strong>快速 Fast(F)：测试应该足够快；如果测试过慢就不愿进行测试，最终导致代码腐败；</strong><br><strong>独立 Independent(I)：测试应该相互独立，某个测试不应为下一个测试设定条件；以任何顺序运行测试条件也是可以的；</strong><br><strong>可重复 Repeatable(R)：测试可以在任何环境中通过；比如生产环境，质检环境；</strong><br><strong>自足验证 Self-Validating(S)：测试应该有布尔值输出；无论成败，可以方便检测。</strong><br><strong>及时 Timely(T)：测试应该及时编写；单元测试应该恰好在使其通过的生产代码之前编写；</strong></p></li><li><h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p>如果你坐视测试腐坏,那么代码也会跟着腐坏。保持测试整洁吧。</p></li></ul><h3 id="第10章-类"><a href="#第10章-类" class="headerlink" title="第10章 类"></a>第10章 类</h3><ul><li><h4 id="类的组织"><a href="#类的组织" class="headerlink" title="类的组织"></a>类的组织</h4><p>遵循标准的Java约定,类应该从一组变量列表开始。<strong>如果有公共静态常量,应该先出现。</strong></p><p><strong>然后是私有静态变量,以及私有实体变量。很少会有公共变量。</strong></p><p><strong>公共函数应跟在变量列表之后。</strong>我们喜欢把由某个公共函数调用的私有工具函数紧随在该公共函数后面。这符合了自顶向下原则,让程序读起来就像一篇报纸文章。</p></li><li><h4 id="类应该短小"><a href="#类应该短小" class="headerlink" title="类应该短小"></a>类应该短小</h4><p><strong>类应该短小，单一权原则（SRP）。</strong></p><p><strong>系统应该由许多短小的类而不是少量巨大的类组成.每个小类封装一个权责,只有一个修改的原因，并与少数其他类一起协同达成期望的系统行为。</strong></p><p><strong>内聚性：</strong></p><p>​    <strong>所谓内聚是指类中的方法基本围绕在类的变量进行操作，与外界很少接触；这样的类方法具有高内聚；</strong></p><p>​    <strong>如果类中变量被每一个方法使用，该类具有最高德内聚性；</strong></p><p>​    <strong>高内聚表明方法与变量相互依赖，相互结合成一个逻辑整体；</strong></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;ol&gt;
&lt;li&gt; 阅读本书有两种原因：第一，你是个程序员；第二，你想成为更好的程序员。&lt;/li&gt;
&lt;li&gt; 这是本有关编写好程序的书。它充斥着代码。我们要从各个方向来考察这些代码。从顶向下,从底往上,从里而外。读完后,就能知道许多关于代码的事了。而且,我们还能说出好代码和糟糕的代码之间的差异。我们将了解到如何写出好代码。我们也会知道,如何将糟糕的代码改成好代码。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="阅读笔记" scheme="https://blog.methodref.top/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="书籍" scheme="https://blog.methodref.top/tags/%E4%B9%A6%E7%B1%8D/"/>
    
    <category term="编码" scheme="https://blog.methodref.top/tags/%E7%BC%96%E7%A0%81/"/>
    
    <category term="基础" scheme="https://blog.methodref.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>经典排序算法图解&lt;二&gt;</title>
    <link href="https://blog.methodref.top/2020/10/05/6.%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%3C%E4%BA%8C%3E/"/>
    <id>https://blog.methodref.top/2020/10/05/6.%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%3C%E4%BA%8C%3E/</id>
    <published>2020-10-04T16:00:00.000Z</published>
    <updated>2021-06-14T01:28:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>基于&lt;&lt;算法 第四版&gt;中标准绘图库stdDraw实现的算法图解。</p><p>进阶：希尔排序、归并排序、快速排序</p><span id="more"></span><!-- toc --><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>希尔排序是希尔于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n^2)的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。<br>希尔排序是把记录按一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组所包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 </p><h5 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h5><p>在此我们选择希尔排序增量为gap = length / 2，缩小增量继续以gap = gap / 2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2,…,1},称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。最优增量可查看《希尔排序最佳增量序列研究》文章认为是认为第 <em>k</em> 趟排序扫描的增量步长为 2^k - 1。</p><ul><li>选择一个增量序列t1, t2, …, tk,其中ti &gt; tj, tk = 1;</li><li>按增量序列个数k，对序列进行k趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序序列分隔成若干长度为m的子序列，分别对各子序列进行直接插入排序。仅增量因子为1时，整个序列作为一个表来处理，子序列长度即为整个序列的长度。</li></ul><h5 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h5><img src="https://i.loli.net/2021/06/11/7zqoe3w1TXCIEPO.gif" alt="希尔排序" style="zoom:75%;" /><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length / <span class="number">2</span>; i &gt; <span class="number">0</span>; i /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; array.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = j;</span><br><span class="line">                <span class="keyword">while</span> (index - i &gt;= <span class="number">0</span> &amp;&amp; array[index] &lt; array[index - i]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> i1 = array[index];</span><br><span class="line">                    array[index] = array[index - i];</span><br><span class="line">                    array[index - i] = i1;</span><br><span class="line">                    index -= i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p><h5 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h5><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><h5 id="动图展示-1"><a href="#动图展示-1" class="headerlink" title="动图展示"></a>动图展示</h5><img src="https://i.loli.net/2021/06/11/3Ezl8sTJ9Y2Di6B.gif" alt="归并排序" style="zoom:75%;" /><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length]; <span class="comment">// 提前创建好临时输出,避免频繁开辟临时空间</span></span><br><span class="line">       msort(array, <span class="number">0</span>, array.length - <span class="number">1</span>, temp);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 递归分组</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">msort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">           <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">           msort(array, left, mid, temp);</span><br><span class="line">           msort(array, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">           merge(array, left, mid, right, temp);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 合并有序数组</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> l = left;</span><br><span class="line">       <span class="keyword">int</span> r = mid + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">// 两个数组各自未到边界</span></span><br><span class="line">       <span class="keyword">while</span> (l &lt;= mid &amp;&amp; r &lt;= right) &#123;</span><br><span class="line">           temp[t++] = array[l] &gt; array[r] ? array[r++] : array[l++];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 处理左边剩下的元素</span></span><br><span class="line">       <span class="keyword">while</span> (l &lt;= mid) &#123;</span><br><span class="line">           temp[t++] = array[l++];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 处理右边剩下的元素</span></span><br><span class="line">       <span class="keyword">while</span> (r &lt;= right) &#123;</span><br><span class="line">           temp[t++] = array[r++];</span><br><span class="line">       &#125;</span><br><span class="line">       t = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">// 从临时数组拷贝到原始数组</span></span><br><span class="line">       <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">           array[left++] = temp[t++];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h5 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h5><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><h5 id="动图展示-2"><a href="#动图展示-2" class="headerlink" title="动图展示"></a>动图展示</h5><img src="https://i.loli.net/2021/06/11/jZa9AShdVGfvYen.gif" alt="快速排序" style="zoom:75%;" /><h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> center = array[left];</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = right;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; array[j] &gt;= center) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; array[i] &lt;= center) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                t = array[i];</span><br><span class="line">                array[i] = array[j];</span><br><span class="line">                array[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        array[left] = array[i];</span><br><span class="line">        array[i] = center;</span><br><span class="line">        quickSort(array, left, i - <span class="number">1</span>);</span><br><span class="line">        quickSort(array, i + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="动图实现代码"><a href="#动图实现代码" class="headerlink" title="动图实现代码"></a>动图实现代码</h4><p>依赖 《算法 第四版》提供的工具包 algs4.jar，可去《算法 第四版》提供的资源 <a href="https://algs4.cs.princeton.edu/code/">Java算法和客户端</a> 去下载。</p><p><a href="https://algs4.cs.princeton.edu/code/">Java算法和客户端</a> 提供的下载链接： <a href="https://algs4.cs.princeton.edu/code/algs4.jar">algs4.jar</a>。</p><p>后续实现的排序算法动图基于这些代码基础上，进行修改追加。</p><p>可以直接这个系列最后一篇下载所有的排序动画排序代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdDraw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.Color;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: DemoProject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Methodref</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-10-02 14:34</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// X轴比例尺</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> X_SCALE = <span class="number">45</span>;</span><br><span class="line">    <span class="comment">// Y轴比例尺</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Y_SCALE = <span class="number">50</span>;</span><br><span class="line">    <span class="comment">// 默认窗口宽度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANVAS_WIDTH = X_SCALE * <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 默认窗口高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANVAS_HEIGHT = Y_SCALE * <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 数组大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_SIZE = <span class="number">15</span>;   <span class="comment">// 窗口大小设置最适合的数字</span></span><br><span class="line">    <span class="comment">// 数组最小值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_MIN_VALUE = <span class="number">4</span>; <span class="comment">// 防止出现0导致的图形展示异常</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认矩形颜色</span></span><br><span class="line"><span class="comment">//    private static final Color defaultColor = new Color(163, 84, 88);</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Color defaultColor = <span class="keyword">new</span> Color(<span class="number">216</span>, <span class="number">216</span>, <span class="number">216</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Color orderlyGroupColor = <span class="keyword">new</span> Color(<span class="number">161</span>, <span class="number">186</span>, <span class="number">176</span>, <span class="number">255</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Color groupColorA = <span class="keyword">new</span> Color(<span class="number">42</span>, <span class="number">86</span>, <span class="number">181</span>, <span class="number">255</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Color groupColorB = <span class="keyword">new</span> Color(<span class="number">72</span>, <span class="number">171</span>, <span class="number">131</span>, <span class="number">255</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Color compareColor = <span class="keyword">new</span> Color(<span class="number">88</span>, <span class="number">254</span>, <span class="number">219</span>, <span class="number">128</span>);</span><br><span class="line">    <span class="comment">// 索引颜色</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Color indexColor = <span class="keyword">new</span> Color(<span class="number">86</span>, <span class="number">245</span>, <span class="number">105</span>, <span class="number">144</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化画布</span></span><br><span class="line">        initCanvas();</span><br><span class="line">        <span class="keyword">int</span>[] array = getRandomArray(ARRAY_SIZE);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">        quickSort(array, <span class="number">0</span>, array.length - <span class="number">1</span>); <span class="comment">// 快速排序</span></span><br><span class="line"><span class="comment">//        mergeSort(array); // 归并排序</span></span><br><span class="line"><span class="comment">//        shellSort(array); //希尔排序</span></span><br><span class="line"><span class="comment">//        insertionSort(array); // 插入排序</span></span><br><span class="line"><span class="comment">//        selectionSort(array); // 选择排序</span></span><br><span class="line"><span class="comment">//        bubbleSort(array); // 冒泡排序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        StdDrawUtil.refreshArray(array, defaultColor, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 标记该循环内排序的数组</span></span><br><span class="line">        <span class="keyword">int</span>[] sortGroup = getSortGroup(left, right);</span><br><span class="line">        StdDrawUtil.markRectangles(array, sortGroup, groupColorB, <span class="number">100</span>);</span><br><span class="line">        StdDrawUtil.markRectangle(array, left, groupColorA, <span class="string">&quot;C&quot;</span>, <span class="number">500</span>);</span><br><span class="line">        <span class="keyword">int</span> center = array[left];</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = right;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; array[j] &gt;= center) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; array[i] &lt;= center) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                t = array[i];</span><br><span class="line">                array[i] = array[j];</span><br><span class="line">                array[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        array[left] = array[i];</span><br><span class="line">        array[i] = center;</span><br><span class="line">        StdDrawUtil.refreshArray(array, defaultColor, -<span class="number">1</span>);</span><br><span class="line">        StdDrawUtil.markRectangles(array, sortGroup, groupColorB, <span class="number">1</span>);</span><br><span class="line">        StdDrawUtil.markRectangle(array, i, groupColorA, <span class="string">&quot;C&quot;</span>, <span class="number">500</span>);</span><br><span class="line">        quickSort(array, left, i - <span class="number">1</span>);</span><br><span class="line">        quickSort(array, i + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getSortGroup(<span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] indexs = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; indexs.length; i++) &#123;</span><br><span class="line">            indexs[i] = left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> indexs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 归并排序图形化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length]; <span class="comment">// 提前创建好临时输出,避免频繁开辟临时空间</span></span><br><span class="line">        msort(array, <span class="number">0</span>, array.length - <span class="number">1</span>, temp);</span><br><span class="line">        StdDrawUtil.refreshArray(array, orderlyGroupColor, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归分组</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">msort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            msort(array, left, mid, temp);</span><br><span class="line">            msort(array, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">            merge(array, left, mid, right, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并有序数组</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] leftGroup = getMergeSortIndexGroup(left, mid + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span>[] rightGroup = getMergeSortIndexGroup(mid, right);</span><br><span class="line">        StdDrawUtil.refreshArray(array, defaultColor, -<span class="number">1</span>);</span><br><span class="line">        StdDrawUtil.markRectangles(array, leftGroup, groupColorA, <span class="number">100</span>);</span><br><span class="line">        StdDrawUtil.markRectangles(array, rightGroup, groupColorB, <span class="number">600</span>);</span><br><span class="line">        <span class="keyword">int</span> l = left;</span><br><span class="line">        <span class="keyword">int</span> r = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 两个数组各自未到边界</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= mid &amp;&amp; r &lt;= right) &#123;</span><br><span class="line">            temp[t++] = array[l] &gt; array[r] ? array[r++] : array[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理左边剩下的元素</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= mid) &#123;</span><br><span class="line">            temp[t++] = array[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理右边剩下的元素</span></span><br><span class="line">        <span class="keyword">while</span> (r &lt;= right) &#123;</span><br><span class="line">            temp[t++] = array[r++];</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 从临时数组拷贝到原始数组</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            array[left++] = temp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">        StdDrawUtil.refreshArray(array, defaultColor, -<span class="number">1</span>);</span><br><span class="line">        StdDrawUtil.markRectangles(array, leftGroup, groupColorA, <span class="number">100</span>);</span><br><span class="line">        StdDrawUtil.markRectangles(array, rightGroup, groupColorB, <span class="number">600</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取归并数组分组信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getMergeSortIndexGroup(<span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line">        right = right + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] indexes = <span class="keyword">new</span> <span class="keyword">int</span>[right - left];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; indexes.length; i++) &#123;</span><br><span class="line">            indexes[i] = left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> indexes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 希尔排序图形化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length / <span class="number">2</span>; i &gt; <span class="number">0</span>; i /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; array.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = j;</span><br><span class="line">                <span class="keyword">int</span>[] compareGroup = getShellSortCompareGroup(j, i, array.length);</span><br><span class="line">                StdDrawUtil.refreshArray(array, defaultColor, -<span class="number">1</span>);</span><br><span class="line">                StdDrawUtil.markRectangles(array, compareGroup, orderlyGroupColor, -<span class="number">1</span>);</span><br><span class="line">                StdDrawUtil.markRectangle(array, index, indexColor, <span class="string">&quot;P&quot;</span>, <span class="number">500</span>);</span><br><span class="line">                <span class="keyword">if</span> (array[index] &gt;= array[index - i])</span><br><span class="line">                    StdDrawUtil.markRectangle(array, index - i, compareColor, <span class="string">&quot;C&quot;</span>, <span class="number">500</span>);</span><br><span class="line">                <span class="keyword">while</span> (index - i &gt;= <span class="number">0</span> &amp;&amp; array[index] &lt; array[index - i]) &#123;</span><br><span class="line">                    StdDrawUtil.refreshArray(array, defaultColor, -<span class="number">1</span>);</span><br><span class="line">                    StdDrawUtil.markRectangles(array, compareGroup, orderlyGroupColor, -<span class="number">1</span>);</span><br><span class="line">                    StdDrawUtil.markRectangle(array, index, indexColor, <span class="string">&quot;P&quot;</span>, <span class="number">200</span>);</span><br><span class="line">                    StdDrawUtil.markRectangle(array, index - i, compareColor, <span class="string">&quot;C&quot;</span>, <span class="number">200</span>);</span><br><span class="line">                    StdDrawUtil.exchangeAnimation(array, index, indexColor, index - i, compareColor);</span><br><span class="line">                    <span class="keyword">int</span> i1 = array[index];</span><br><span class="line">                    array[index] = array[index - i];</span><br><span class="line">                    array[index - i] = i1;</span><br><span class="line">                    index -= i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] group = getOrderlyGroup(array.length);</span><br><span class="line">        StdDrawUtil.refreshArray(array, defaultColor, -<span class="number">1</span>);</span><br><span class="line">        StdDrawUtil.markRectangles(array, group, orderlyGroupColor, <span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取shell组信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getShellSortCompareGroup(<span class="keyword">int</span> start, <span class="keyword">int</span> increment, <span class="keyword">int</span> length) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>) Math.ceil((<span class="keyword">double</span>) length / increment)];</span><br><span class="line">        Arrays.fill(ints, -<span class="number">1</span>);  <span class="comment">// -1为了排除默认0导致的重复绘画</span></span><br><span class="line">        <span class="keyword">while</span> (start - increment &gt;= <span class="number">0</span>)</span><br><span class="line">            start -= increment;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (start &gt;= length) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ints[i] = start;</span><br><span class="line">            start += increment;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ints;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入排序图形化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = i;</span><br><span class="line">            <span class="comment">// 有序组</span></span><br><span class="line">            <span class="keyword">int</span>[] group = getOrderlyGroup(i);</span><br><span class="line">            StdDrawUtil.refreshArray(array, defaultColor, -<span class="number">1</span>);</span><br><span class="line">            StdDrawUtil.markRectangles(array, group, orderlyGroupColor, -<span class="number">1</span>);</span><br><span class="line">            StdDrawUtil.markRectangle(array, index, indexColor, <span class="string">&quot;P&quot;</span>, <span class="number">500</span>);</span><br><span class="line">            <span class="keyword">if</span> (index &gt; <span class="number">0</span> &amp;&amp; array[index] &gt;= array[index - <span class="number">1</span>])</span><br><span class="line">                StdDrawUtil.markRectangle(array, index - <span class="number">1</span>, compareColor, <span class="string">&quot;C&quot;</span>, <span class="number">200</span>);</span><br><span class="line">            <span class="keyword">while</span> (index &gt; <span class="number">0</span> &amp;&amp; array[index] &lt; array[index - <span class="number">1</span>]) &#123;</span><br><span class="line">                StdDrawUtil.markRectangle(array, index, indexColor, <span class="string">&quot;P&quot;</span>, <span class="number">200</span>);</span><br><span class="line">                StdDrawUtil.markRectangle(array, index - <span class="number">1</span>, compareColor, <span class="string">&quot;C&quot;</span>, <span class="number">500</span>);</span><br><span class="line">                StdDrawUtil.exchangeAnimation(array, index, indexColor, index - <span class="number">1</span>, compareColor);</span><br><span class="line">                <span class="keyword">int</span> i1 = array[index];</span><br><span class="line">                array[index] = array[index - <span class="number">1</span>];</span><br><span class="line">                array[index - <span class="number">1</span>] = i1;</span><br><span class="line">                index--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] group = getOrderlyGroup(array.length);</span><br><span class="line">        StdDrawUtil.refreshArray(array, defaultColor, -<span class="number">1</span>);</span><br><span class="line">        StdDrawUtil.markRectangles(array, group, orderlyGroupColor, <span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择排序图形化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 刷新页面</span></span><br><span class="line">            <span class="keyword">int</span> index = i;</span><br><span class="line">            <span class="keyword">int</span>[] group = getOrderlyGroup(i);</span><br><span class="line">            StdDrawUtil.refreshArray(array, defaultColor, -<span class="number">1</span>);</span><br><span class="line">            StdDrawUtil.markRectangles(array, group, orderlyGroupColor, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">                StdDrawUtil.refreshArray(array, defaultColor, -<span class="number">1</span>);</span><br><span class="line">                StdDrawUtil.markRectangles(array, group, orderlyGroupColor, -<span class="number">1</span>);</span><br><span class="line">                StdDrawUtil.markRectangle(array, index, indexColor, <span class="string">&quot;P&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">                StdDrawUtil.markRectangle(array, j, compareColor, <span class="string">&quot;C&quot;</span>, <span class="number">500</span>);</span><br><span class="line">                <span class="keyword">if</span> (array[index] &gt; array[j]) &#123;</span><br><span class="line">                    index = j;</span><br><span class="line">                    StdDrawUtil.refreshArray(array, defaultColor, -<span class="number">1</span>);</span><br><span class="line">                    StdDrawUtil.markRectangles(array, group, orderlyGroupColor, -<span class="number">1</span>);</span><br><span class="line">                    StdDrawUtil.markRectangle(array, index, indexColor, <span class="string">&quot;P&quot;</span>, <span class="number">500</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 渲染交换动画效果</span></span><br><span class="line">            StdDrawUtil.exchangeAnimation(array, i, defaultColor, index, indexColor);</span><br><span class="line">            <span class="keyword">int</span> i1 = array[i];</span><br><span class="line">            array[i] = array[index];</span><br><span class="line">            array[index] = i1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] group = getOrderlyGroup(array.length);</span><br><span class="line">        StdDrawUtil.refreshArray(array, defaultColor, -<span class="number">1</span>);</span><br><span class="line">        StdDrawUtil.markRectangles(array, group, orderlyGroupColor, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 冒泡排序图形化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 刷新页面</span></span><br><span class="line">            <span class="keyword">int</span>[] group = getBubbleSortOrderlyGroup(i, array.length);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                StdDrawUtil.refreshArray(array, defaultColor, -<span class="number">1</span>);</span><br><span class="line">                StdDrawUtil.markRectangles(array, group, orderlyGroupColor, -<span class="number">1</span>);</span><br><span class="line">                StdDrawUtil.markRectangle(array, j, indexColor, <span class="string">&quot;P&quot;</span>, <span class="number">200</span>);</span><br><span class="line">                StdDrawUtil.markRectangle(array, j + <span class="number">1</span>, compareColor, <span class="string">&quot;C&quot;</span>, <span class="number">200</span>);</span><br><span class="line">                <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 渲染交换动画效果</span></span><br><span class="line">                    StdDrawUtil.exchangeAnimation(array, j, indexColor, j + <span class="number">1</span>, compareColor);</span><br><span class="line">                    <span class="keyword">int</span> i1 = array[j];</span><br><span class="line">                    array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                    array[j + <span class="number">1</span>] = i1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] group = getOrderlyGroup(array.length);</span><br><span class="line">        StdDrawUtil.refreshArray(array, defaultColor, -<span class="number">1</span>);</span><br><span class="line">        StdDrawUtil.markRectangles(array, group, orderlyGroupColor, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getOrderlyGroup(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] group = <span class="keyword">new</span> <span class="keyword">int</span>[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; group.length; j++) &#123;</span><br><span class="line">            group[j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> group;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getBubbleSortOrderlyGroup(<span class="keyword">int</span> i, <span class="keyword">int</span> length) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[length - i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ints.length; j++) &#123;</span><br><span class="line">            ints[j] = --length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ints;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化画布和比例尺</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initCanvas</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StdDraw.setCanvasSize(CANVAS_WIDTH, CANVAS_HEIGHT);</span><br><span class="line">        StdDraw.setXscale(-<span class="number">2</span>, X_SCALE); <span class="comment">// -2 是为了美观</span></span><br><span class="line">        StdDraw.setYscale(<span class="number">0</span>, Y_SCALE);</span><br><span class="line">        StdDraw.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取随机数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getRandomArray(<span class="keyword">int</span> length) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = random.nextInt(Y_SCALE - ARRAY_MIN_VALUE) + ARRAY_MIN_VALUE - <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdDraw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.Color;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: DemoProject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 排序绘制工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Methodref</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-10-02 14:39</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StdDrawUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 间距</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERVAL = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 矩形宽度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RECTANGLE_WIDTH = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// X轴比例尺</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> X_SCALE = <span class="number">45</span>;</span><br><span class="line">    <span class="comment">// Y轴比例尺</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Y_SCALE = <span class="number">50</span>;</span><br><span class="line">    <span class="comment">// 默认窗口宽度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANVAS_WIDTH = X_SCALE * <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 默认窗口高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANVAS_HEIGHT = <span class="number">60</span> * <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 数组大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_SIZE = <span class="number">2</span>;   <span class="comment">// 窗口大小设置最适合的数字</span></span><br><span class="line">    <span class="comment">// 数组最小值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_MIN_VALUE = <span class="number">4</span>; <span class="comment">// 防止出现0导致的图形展示异常</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认矩形颜色</span></span><br><span class="line"><span class="comment">//    private static final Color defaultColor = new Color(216, 216, 216);</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Color defaultColor = <span class="keyword">new</span> Color(<span class="number">216</span>, <span class="number">216</span>, <span class="number">216</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Color textColor = <span class="keyword">new</span> Color(<span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 画矩形</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> color</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drawRectangle</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value, Color color)</span> </span>&#123;</span><br><span class="line">        StdDraw.setPenColor(color);</span><br><span class="line">        StdDraw.filledRectangle(index * INTERVAL, <span class="number">0</span>, RECTANGLE_WIDTH, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 填充数值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> color</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drawNum</span><span class="params">(<span class="keyword">double</span> index, <span class="keyword">int</span> value, Color color)</span> </span>&#123;</span><br><span class="line">        StdDraw.setPenColor(color);</span><br><span class="line">        StdDraw.text(index * INTERVAL, value / <span class="number">2</span>, String.valueOf(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 填充字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> color</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drawString</span><span class="params">(<span class="keyword">double</span> index, <span class="keyword">int</span> value, String string, Color color)</span> </span>&#123;</span><br><span class="line">        StdDraw.setPenColor(color);</span><br><span class="line">        StdDraw.text(index * INTERVAL, value / <span class="number">2</span> + <span class="number">1</span>, string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交互动画</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> indexA</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> indexB</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchangeAnimation</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> indexA, Color changeColorA, <span class="keyword">int</span> indexB, Color changeColorB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> speed = <span class="number">15</span>; <span class="comment">// 交换渲染次数</span></span><br><span class="line">        <span class="keyword">double</span> abs = (<span class="keyword">double</span>) Math.abs(indexA - indexB) / speed;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; speed; i++) &#123;</span><br><span class="line">            StdDraw.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == indexA) &#123;</span><br><span class="line">                    <span class="keyword">double</span> aX;</span><br><span class="line">                    <span class="keyword">double</span> bX;</span><br><span class="line">                    <span class="keyword">if</span> (indexA &gt; indexB) &#123;</span><br><span class="line">                        aX = (indexA - i * abs) * INTERVAL;</span><br><span class="line">                        bX = (indexB + i * abs) * INTERVAL;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        aX = (indexA + i * abs) * INTERVAL;</span><br><span class="line">                        bX = (indexB - i * abs) * INTERVAL;</span><br><span class="line">                    &#125;</span><br><span class="line">                    StdDraw.setPenColor(changeColorA);</span><br><span class="line">                    StdDraw.filledRectangle(aX, <span class="number">0</span>, RECTANGLE_WIDTH, array[indexA]);</span><br><span class="line">                    StdDraw.setPenColor(changeColorB);</span><br><span class="line">                    StdDraw.filledRectangle(bX, <span class="number">0</span>, RECTANGLE_WIDTH, array[indexB]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j != indexB) &#123;</span><br><span class="line">                    drawRectangle(j, array[j], defaultColor);</span><br><span class="line">                    drawNum(j, array[j], textColor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            StdDraw.enableDoubleBuffering();</span><br><span class="line">            StdDraw.show();</span><br><span class="line">            StdDraw.pause(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写标题</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> y</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> color</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> title</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drawTitle</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, Color color, String title)</span> </span>&#123;</span><br><span class="line">        StdDraw.setPenColor(color);</span><br><span class="line">        StdDraw.text(x, y, String.valueOf(title));</span><br><span class="line">        StdDraw.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 画比例尺</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drawScale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            StdDraw.text(<span class="number">1</span>, i, String.valueOf(i));</span><br><span class="line">            StdDraw.text(i, <span class="number">1</span>, String.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过下标数组标记矩形</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> indexes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">markRectangles</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span>[] indexes, Color markColor, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index : indexes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">                drawRectangle(index, array[index], markColor);</span><br><span class="line">                drawNum(index, array[index], textColor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        setDisplayTime(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 刷新数组矩形展示</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> defaultColor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">refreshArray</span><span class="params">(<span class="keyword">int</span>[] array, Color defaultColor, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        StdDraw.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">            drawRectangle(j, array[j], defaultColor);</span><br><span class="line">            drawNum(j, array[j], textColor);</span><br><span class="line">        &#125;</span><br><span class="line">        setDisplayTime(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">markRectangle</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> index, Color color, String tip, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        drawRectangle(index, array[index], color);</span><br><span class="line">        <span class="keyword">if</span> (tip != <span class="keyword">null</span>)</span><br><span class="line">            drawString(index, array[index], tip, textColor);</span><br><span class="line">        drawNum(index, array[index], textColor);</span><br><span class="line">        setDisplayTime(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDisplayTime</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            StdDraw.enableDoubleBuffering();</span><br><span class="line">            StdDraw.show();</span><br><span class="line">            StdDraw.pause(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">waitRefresh</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        StdDraw.pause(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;基于&amp;lt;&amp;lt;算法 第四版&amp;gt;中标准绘图库stdDraw实现的算法图解。&lt;/p&gt;
&lt;p&gt;进阶：希尔排序、归并排序、快速排序&lt;/p&gt;</summary>
    
    
    
    <category term="技术类" scheme="https://blog.methodref.top/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB/"/>
    
    
    <category term="算法" scheme="https://blog.methodref.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序算法" scheme="https://blog.methodref.top/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="基础算法" scheme="https://blog.methodref.top/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>经典排序算法图解&lt;一&gt;</title>
    <link href="https://blog.methodref.top/2020/10/02/5.%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%3C%E4%B8%80%3E/"/>
    <id>https://blog.methodref.top/2020/10/02/5.%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%3C%E4%B8%80%3E/</id>
    <published>2020-10-01T16:00:00.000Z</published>
    <updated>2021-06-14T01:27:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>基于&lt;&lt;算法 第四版&gt;中标准绘图库stdDraw实现的算法图解。</p><p>简单：冒泡排序、选择排序、插入排序</p><span id="more"></span><!-- toc --><h4 id="前述"><a href="#前述" class="headerlink" title="前述"></a>前述</h4><p>早些时候阅读&lt;&lt;算法 第四版&gt;&gt;时，第一章基础中stdDraw标准绘图库工具时做过一些小的demo觉得挺有趣，于是产生了完成一个解释排序算法图解的一个想法，直至今日，开始写博客时才付诸于行动去实现这个功能。</p><p>先实现了几个简单的排序算法图解，后续再去补充其他的排序算法。</p><h4 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h4><ul><li><p><strong>比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序</p></li><li><p><strong>非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</p><p><img src="https://i.loli.net/2021/05/12/1a3O6LgkzKnBqEw.png" alt="img"></p></li></ul><h4 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h4><p><img src="https://i.loli.net/2021/05/12/UKhftNrmPbI6yqE.png" alt="img"></p><p><strong>相关概念</strong></p><ul><li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li><li><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li><li><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li><li><strong>空间复杂度：</strong>是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</li></ul><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 </p><h5 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h5><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><h5 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h5><img src="https://i.loli.net/2021/06/11/Wanhkz2ADYloLve.gif" alt="冒泡排序" style="zoom:75%;" /><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        StdDrawUtil.refreshArray(array, <span class="number">200</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> i1 = array[j];</span><br><span class="line">                array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                array[j + <span class="number">1</span>] = i1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><h5 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h5><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><h5 id="动图展示-1"><a href="#动图展示-1" class="headerlink" title="动图展示"></a>动图展示</h5><img src="https://i.loli.net/2021/06/11/GkDYgAx6HcSJEab.gif" alt="选择排序" style="zoom:75%;" /><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[index] &gt; array[j]) &#123;</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i1 = array[i];</span><br><span class="line">        array[i] = array[index];</span><br><span class="line">        array[index] = i1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><h5 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h5><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><h5 id="动图展示-2"><a href="#动图展示-2" class="headerlink" title="动图展示"></a>动图展示</h5><img src="https://i.loli.net/2021/06/11/KH3jnPFR9mxtvzS.gif" alt="插入排序" style="zoom:75%;" /><h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = array[i];</span><br><span class="line">        <span class="keyword">int</span> preIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current &lt; array[j]) &#123;</span><br><span class="line">                array[preIndex] = array[j];</span><br><span class="line">                preIndex = j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        array[preIndex] = current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="动图实现代码"><a href="#动图实现代码" class="headerlink" title="动图实现代码"></a>动图实现代码</h4><p>依赖 《算法 第四版》提供的工具包 algs4.jar，可去《算法 第四版》提供的资源 <a href="https://algs4.cs.princeton.edu/code/">Java算法和客户端</a> 去下载。</p><p><a href="https://algs4.cs.princeton.edu/code/">Java算法和客户端</a> 提供的下载链接： <a href="https://algs4.cs.princeton.edu/code/algs4.jar">algs4.jar</a>。</p><p>后续实现的排序算法动图基于这些代码基础上，进行修改追加。</p><p>可以直接这个系列最后一篇下载所有的排序动画排序代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdDraw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.Color;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: DemoProject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Methodref</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-10-02 14:34</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// X轴比例尺</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> X_SCALE = <span class="number">45</span>;</span><br><span class="line">    <span class="comment">// Y轴比例尺</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Y_SCALE = <span class="number">50</span>;</span><br><span class="line">    <span class="comment">// 默认窗口宽度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANVAS_WIDTH = X_SCALE * <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 默认窗口高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANVAS_HEIGHT = Y_SCALE * <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 数组大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_SIZE = <span class="number">15</span>;   <span class="comment">// 窗口大小设置最适合的数字</span></span><br><span class="line">    <span class="comment">// 数组最小值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_MIN_VALUE = <span class="number">4</span>; <span class="comment">// 防止出现0导致的图形展示异常</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认矩形颜色</span></span><br><span class="line"><span class="comment">//    private static final Color defaultColor = new Color(163, 84, 88);</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Color defaultColor = <span class="keyword">new</span> Color(<span class="number">216</span>, <span class="number">216</span>, <span class="number">216</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Color orderlyGroupColor = <span class="keyword">new</span> Color(<span class="number">161</span>, <span class="number">186</span>, <span class="number">176</span>, <span class="number">255</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Color compareColor = <span class="keyword">new</span> Color(<span class="number">88</span>, <span class="number">254</span>, <span class="number">219</span>, <span class="number">128</span>);</span><br><span class="line">    <span class="comment">// 索引颜色</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Color indexColor = <span class="keyword">new</span> Color(<span class="number">86</span>, <span class="number">245</span>, <span class="number">105</span>, <span class="number">144</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化画布</span></span><br><span class="line">        initCanvas();</span><br><span class="line">        <span class="keyword">int</span>[] array = getRandomArray(ARRAY_SIZE);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">        insertionSort(array); <span class="comment">// 插入排序</span></span><br><span class="line"><span class="comment">//        selectionSort(array); // 选择排序</span></span><br><span class="line"><span class="comment">//        bubbleSort(array); // 冒泡排序</span></span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入排序图形化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = i;</span><br><span class="line">            <span class="comment">// 有序组</span></span><br><span class="line">            <span class="keyword">int</span>[] group = getOrderlyGroup(i);</span><br><span class="line">            StdDrawUtil.refreshArray(array, defaultColor, -<span class="number">1</span>);</span><br><span class="line">            StdDrawUtil.markRectangles(array, group, orderlyGroupColor, -<span class="number">1</span>);</span><br><span class="line">            StdDrawUtil.markRectangle(array, index, indexColor, <span class="string">&quot;P&quot;</span>, <span class="number">500</span>);</span><br><span class="line">            <span class="keyword">if</span> (index &gt; <span class="number">0</span> &amp;&amp; array[index] &gt;= array[index - <span class="number">1</span>])</span><br><span class="line">                StdDrawUtil.markRectangle(array, index - <span class="number">1</span>, compareColor, <span class="string">&quot;C&quot;</span>, <span class="number">200</span>);</span><br><span class="line">            <span class="keyword">while</span> (index &gt; <span class="number">0</span> &amp;&amp; array[index] &lt; array[index - <span class="number">1</span>]) &#123;</span><br><span class="line">                StdDrawUtil.markRectangle(array, index, indexColor, <span class="string">&quot;P&quot;</span>, <span class="number">200</span>);</span><br><span class="line">                StdDrawUtil.markRectangle(array, index - <span class="number">1</span>, compareColor, <span class="string">&quot;C&quot;</span>, <span class="number">500</span>);</span><br><span class="line">                StdDrawUtil.exchangeAnimation(array, index, indexColor, index - <span class="number">1</span>, compareColor);</span><br><span class="line">                <span class="keyword">int</span> i1 = array[index];</span><br><span class="line">                array[index] = array[index - <span class="number">1</span>];</span><br><span class="line">                array[index - <span class="number">1</span>] = i1;</span><br><span class="line">                index--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] group = getOrderlyGroup(array.length);</span><br><span class="line">        StdDrawUtil.refreshArray(array, defaultColor, -<span class="number">1</span>);</span><br><span class="line">        StdDrawUtil.markRectangles(array, group, orderlyGroupColor, <span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择排序图形化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 刷新页面</span></span><br><span class="line">            <span class="keyword">int</span> index = i;</span><br><span class="line">            <span class="keyword">int</span>[] group = getOrderlyGroup(i);</span><br><span class="line">            StdDrawUtil.refreshArray(array, defaultColor, -<span class="number">1</span>);</span><br><span class="line">            StdDrawUtil.markRectangles(array, group, orderlyGroupColor, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">                StdDrawUtil.refreshArray(array, defaultColor, -<span class="number">1</span>);</span><br><span class="line">                StdDrawUtil.markRectangles(array, group, orderlyGroupColor, -<span class="number">1</span>);</span><br><span class="line">                StdDrawUtil.markRectangle(array, index, indexColor, <span class="string">&quot;P&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">                StdDrawUtil.markRectangle(array, j, compareColor, <span class="string">&quot;C&quot;</span>, <span class="number">500</span>);</span><br><span class="line">                <span class="keyword">if</span> (array[index] &gt; array[j]) &#123;</span><br><span class="line">                    index = j;</span><br><span class="line">                    StdDrawUtil.refreshArray(array, defaultColor, -<span class="number">1</span>);</span><br><span class="line">                    StdDrawUtil.markRectangles(array, group, orderlyGroupColor, -<span class="number">1</span>);</span><br><span class="line">                    StdDrawUtil.markRectangle(array, index, indexColor, <span class="string">&quot;P&quot;</span>, <span class="number">500</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 渲染交换动画效果</span></span><br><span class="line">            StdDrawUtil.exchangeAnimation(array, i, defaultColor, index, indexColor);</span><br><span class="line">            <span class="keyword">int</span> i1 = array[i];</span><br><span class="line">            array[i] = array[index];</span><br><span class="line">            array[index] = i1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] group = getOrderlyGroup(array.length);</span><br><span class="line">        StdDrawUtil.refreshArray(array, defaultColor, -<span class="number">1</span>);</span><br><span class="line">        StdDrawUtil.markRectangles(array, group, orderlyGroupColor, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 冒泡排序图形化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 刷新页面</span></span><br><span class="line">            <span class="keyword">int</span>[] group = getBubbleSortOrderlyGroup(i, array.length);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                StdDrawUtil.refreshArray(array, defaultColor, -<span class="number">1</span>);</span><br><span class="line">                StdDrawUtil.markRectangles(array, group, orderlyGroupColor, -<span class="number">1</span>);</span><br><span class="line">                StdDrawUtil.markRectangle(array, j, indexColor, <span class="string">&quot;P&quot;</span>, <span class="number">200</span>);</span><br><span class="line">                StdDrawUtil.markRectangle(array, j + <span class="number">1</span>, compareColor, <span class="string">&quot;C&quot;</span>, <span class="number">200</span>);</span><br><span class="line">                <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 渲染交换动画效果</span></span><br><span class="line">                    StdDrawUtil.exchangeAnimation(array, j, indexColor, j + <span class="number">1</span>, compareColor);</span><br><span class="line">                    <span class="keyword">int</span> i1 = array[j];</span><br><span class="line">                    array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                    array[j + <span class="number">1</span>] = i1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] group = getOrderlyGroup(array.length);</span><br><span class="line">        StdDrawUtil.refreshArray(array, defaultColor, -<span class="number">1</span>);</span><br><span class="line">        StdDrawUtil.markRectangles(array, group, orderlyGroupColor, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getOrderlyGroup(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] group = <span class="keyword">new</span> <span class="keyword">int</span>[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; group.length; j++) &#123;</span><br><span class="line">            group[j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> group;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getBubbleSortOrderlyGroup(<span class="keyword">int</span> i, <span class="keyword">int</span> length) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[length - i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ints.length; j++) &#123;</span><br><span class="line">            ints[j] = --length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ints;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化画布和比例尺</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initCanvas</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StdDraw.setCanvasSize(CANVAS_WIDTH, CANVAS_HEIGHT);</span><br><span class="line">        StdDraw.setXscale(-<span class="number">2</span>, X_SCALE); <span class="comment">// -2 是为了美观</span></span><br><span class="line">        StdDraw.setYscale(<span class="number">0</span>, Y_SCALE);</span><br><span class="line">        StdDraw.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取随机数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getRandomArray(<span class="keyword">int</span> length) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = random.nextInt(Y_SCALE - ARRAY_MIN_VALUE) + ARRAY_MIN_VALUE - <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdDraw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.Color;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: DemoProject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 排序绘制工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Methodref</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-10-02 14:39</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StdDrawUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 间距</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERVAL = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 矩形宽度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RECTANGLE_WIDTH = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// X轴比例尺</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> X_SCALE = <span class="number">45</span>;</span><br><span class="line">    <span class="comment">// Y轴比例尺</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Y_SCALE = <span class="number">50</span>;</span><br><span class="line">    <span class="comment">// 默认窗口宽度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANVAS_WIDTH = X_SCALE * <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 默认窗口高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANVAS_HEIGHT = <span class="number">60</span> * <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 数组大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_SIZE = <span class="number">2</span>;   <span class="comment">// 窗口大小设置最适合的数字</span></span><br><span class="line">    <span class="comment">// 数组最小值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_MIN_VALUE = <span class="number">4</span>; <span class="comment">// 防止出现0导致的图形展示异常</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认矩形颜色</span></span><br><span class="line"><span class="comment">//    private static final Color defaultColor = new Color(216, 216, 216);</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Color defaultColor = <span class="keyword">new</span> Color(<span class="number">216</span>, <span class="number">216</span>, <span class="number">216</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Color textColor = <span class="keyword">new</span> Color(<span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 画矩形</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> color</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drawRectangle</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value, Color color)</span> </span>&#123;</span><br><span class="line">        StdDraw.setPenColor(color);</span><br><span class="line">        StdDraw.filledRectangle(index * INTERVAL, <span class="number">0</span>, RECTANGLE_WIDTH, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 填充数值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> color</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drawNum</span><span class="params">(<span class="keyword">double</span> index, <span class="keyword">int</span> value, Color color)</span> </span>&#123;</span><br><span class="line">        StdDraw.setPenColor(color);</span><br><span class="line">        StdDraw.text(index * INTERVAL, value / <span class="number">2</span>, String.valueOf(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 填充字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> color</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drawString</span><span class="params">(<span class="keyword">double</span> index, <span class="keyword">int</span> value, String string, Color color)</span> </span>&#123;</span><br><span class="line">        StdDraw.setPenColor(color);</span><br><span class="line">        StdDraw.text(index * INTERVAL, value / <span class="number">2</span> + <span class="number">1</span>, string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交互动画</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> indexA</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> indexB</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchangeAnimation</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> indexA, Color changeColorA, <span class="keyword">int</span> indexB, Color changeColorB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> speed = <span class="number">15</span>; <span class="comment">// 交换渲染次数</span></span><br><span class="line">        <span class="keyword">double</span> abs = (<span class="keyword">double</span>) Math.abs(indexA - indexB) / speed;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; speed; i++) &#123;</span><br><span class="line">            StdDraw.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == indexA) &#123;</span><br><span class="line">                    <span class="keyword">double</span> aX;</span><br><span class="line">                    <span class="keyword">double</span> bX;</span><br><span class="line">                    <span class="keyword">if</span> (indexA &gt; indexB) &#123;</span><br><span class="line">                        aX = (indexA - i * abs) * INTERVAL;</span><br><span class="line">                        bX = (indexB + i * abs) * INTERVAL;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        aX = (indexA + i * abs) * INTERVAL;</span><br><span class="line">                        bX = (indexB - i * abs) * INTERVAL;</span><br><span class="line">                    &#125;</span><br><span class="line">                    StdDraw.setPenColor(changeColorA);</span><br><span class="line">                    StdDraw.filledRectangle(aX, <span class="number">0</span>, RECTANGLE_WIDTH, array[indexA]);</span><br><span class="line">                    StdDraw.setPenColor(changeColorB);</span><br><span class="line">                    StdDraw.filledRectangle(bX, <span class="number">0</span>, RECTANGLE_WIDTH, array[indexB]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j != indexB) &#123;</span><br><span class="line">                    drawRectangle(j, array[j], defaultColor);</span><br><span class="line">                    drawNum(j, array[j], textColor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            StdDraw.enableDoubleBuffering();</span><br><span class="line">            StdDraw.show();</span><br><span class="line">            StdDraw.pause(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写标题</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> y</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> color</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> title</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drawTitle</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, Color color, String title)</span> </span>&#123;</span><br><span class="line">        StdDraw.setPenColor(color);</span><br><span class="line">        StdDraw.text(x, y, String.valueOf(title));</span><br><span class="line">        StdDraw.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 画比例尺</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drawScale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            StdDraw.text(<span class="number">1</span>, i, String.valueOf(i));</span><br><span class="line">            StdDraw.text(i, <span class="number">1</span>, String.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过下标数组标记矩形</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> indexes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">markRectangles</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span>[] indexes, Color markColor, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index : indexes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">                drawRectangle(index, array[index], markColor);</span><br><span class="line">                drawNum(index, array[index], textColor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        setDisplayTime(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 刷新数组矩形展示</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> defaultColor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">refreshArray</span><span class="params">(<span class="keyword">int</span>[] array, Color defaultColor, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        StdDraw.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">            drawRectangle(j, array[j], defaultColor);</span><br><span class="line">            drawNum(j, array[j], textColor);</span><br><span class="line">        &#125;</span><br><span class="line">        setDisplayTime(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">markRectangle</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> index, Color color, String tip, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        drawRectangle(index, array[index], color);</span><br><span class="line">        <span class="keyword">if</span> (tip != <span class="keyword">null</span>)</span><br><span class="line">            drawString(index, array[index], tip, textColor);</span><br><span class="line">        drawNum(index, array[index], textColor);</span><br><span class="line">        setDisplayTime(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDisplayTime</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            StdDraw.enableDoubleBuffering();</span><br><span class="line">            StdDraw.show();</span><br><span class="line">            StdDraw.pause(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">waitRefresh</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        StdDraw.pause(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;基于&amp;lt;&amp;lt;算法 第四版&amp;gt;中标准绘图库stdDraw实现的算法图解。&lt;/p&gt;
&lt;p&gt;简单：冒泡排序、选择排序、插入排序&lt;/p&gt;</summary>
    
    
    
    <category term="技术类" scheme="https://blog.methodref.top/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB/"/>
    
    
    <category term="算法" scheme="https://blog.methodref.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序算法" scheme="https://blog.methodref.top/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="基础算法" scheme="https://blog.methodref.top/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>博客插件hexo-algoliasearch</title>
    <link href="https://blog.methodref.top/2020/09/25/4.%E5%8D%9A%E5%AE%A2%E6%8F%92%E4%BB%B6hexo-algoliasearch/"/>
    <id>https://blog.methodref.top/2020/09/25/4.%E5%8D%9A%E5%AE%A2%E6%8F%92%E4%BB%B6hexo-algoliasearch/</id>
    <published>2020-09-24T16:00:00.000Z</published>
    <updated>2021-06-03T03:26:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo博客的搜索插件<a href="https://github.com/LouisBarranqueiro/hexo-algoliasearch">hexo-algoliasearch</a>介绍及其安装和使用。</p><span id="more"></span><!-- toc --><h4 id="前述"><a href="#前述" class="headerlink" title="前述"></a>前述</h4><p>在使用Tranquilpeak主题时就在其文档中看到了搜索功能的插件，但是当时没有时间去详细了解，如今有时间了就去尝试了解下这个插件的安装与使用方式.</p><h4 id="插件介绍"><a href="#插件介绍" class="headerlink" title="插件介绍"></a>插件介绍</h4><p>在hexo-algoliasearch的Github上的描述</p><p>‘A plugin to index posts of your Hexo blog on Algolia’ 一个hexo博客索引帖子插件基于Algolia.</p><p><a href="https://www.algolia.com/">Algolia</a>官网介绍</p><p>‘The flexible AI-powered Search &amp; Discovery platform’ 灵活的基于AI的搜索发现平台.</p><p>百度百科的介绍</p><p>Algolia是一家为网站与移动应用提供托管式搜索API的初创企业，成立于2012年，总部位于旧金山，曾参加过2014年的YC训练营。网站或移动应用只需嵌入简单代码数分钟即可实现搜索功能。</p><p>在博客园中找到了关于Algolia使用的描述<a href="https://www.cnblogs.com/tmlh/p/10452235.html">天莫轮回:Algolia使用教程 。</a></p><p>注册了一个Algolia的账号创建了一个索引大致了解了使用方式。</p><p>​    上传JSON格式的数据，然后调用search接口传递查询参数，会响应你上传的json数据中value包含查询参数的值&lt;仅可以使用字符串，数字无效&gt;</p><p>大体了解了他还有包含查询记录统计，权重 等的一系列的附加功能.</p><p>Algolia<code>的免费许可允许上传</code>10，000<code>条</code>JSON<code>数据，每月允许</code>100，000`次操作（包括上传和搜索）</p><p>然后回到hexo-algoliasearch的介绍文档中看到操作步骤中有配置环境变量的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">algolia:</span><br><span class="line">  appId: &quot;&quot;</span><br><span class="line">  apiKey: &quot;&quot;</span><br><span class="line">  adminApiKey: &quot;&quot;</span><br><span class="line">  chunkSize: 5000</span><br><span class="line">  indexName: &quot;&quot;</span><br><span class="line">  fields:</span><br><span class="line">    - content:strip:truncate，0，500</span><br><span class="line">    - excerpt:strip</span><br><span class="line">    - gallery</span><br><span class="line">    - permalink</span><br><span class="line">    - photos</span><br><span class="line">    - slug</span><br><span class="line">    - tags</span><br><span class="line">    - title</span><br></pre></td></tr></table></figure><p>至此大致了解了它的实现思路大概如下.</p><p>​    通过配置文件中<code>fields</code>属性，读取每个博客文件设置的属性同时获取到博客的静态页面地址，以此生成出json数据 将json数据通过配置的algolia用户校验信息发送到Algolia服务中进行索引，查询时再通过校验信息调用Algolia查询api响应出对应json数据通过json数据进行跳转.</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>进入到博客根目录下 执行<code>npm install hexo-algoliasearch --save</code>命令进行安装</p><p>修改博客根目录下_config.yml配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">plugins:</span><br><span class="line">  - hexo-algoliasearch</span><br><span class="line">algolia:</span><br><span class="line">  appId: &quot;&quot;</span><br><span class="line">  apiKey: &quot;&quot;</span><br><span class="line">  adminApiKey: &quot;&quot;</span><br><span class="line">  chunkSize: 5000</span><br><span class="line">  indexName: &quot;&quot;</span><br><span class="line">  fields:</span><br><span class="line">    - content:strip:truncate，0，500</span><br><span class="line">    - excerpt:strip</span><br><span class="line">    - gallery</span><br><span class="line">    - permalink</span><br><span class="line">    - photos</span><br><span class="line">    - slug</span><br><span class="line">    - tags</span><br><span class="line">    - title</span><br></pre></td></tr></table></figure><p>将上述参数所需补齐appId，apiKey，adminApiKey，indexName 这些数据可以在Algolia注册账号进行设置获取.</p><p>至此安装成功。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>在博客根目录下执行 <code>hexo algolia</code></p><p>额外参数-n， –no-clear Algolia不清除已存在的索引内容。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Hexo博客的搜索插件&lt;a href=&quot;https://github.com/LouisBarranqueiro/hexo-algoliasearch&quot;&gt;hexo-algoliasearch&lt;/a&gt;介绍及其安装和使用。&lt;/p&gt;</summary>
    
    
    
    <category term="博客" scheme="https://blog.methodref.top/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="博客相关" scheme="https://blog.methodref.top/tags/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>博客主题Tranquilpeak</title>
    <link href="https://blog.methodref.top/2020/09/21/3.%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98Tranquilpeak/"/>
    <id>https://blog.methodref.top/2020/09/21/3.%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98Tranquilpeak/</id>
    <published>2020-09-20T16:00:00.000Z</published>
    <updated>2021-05-12T09:28:23.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak">Tranquilpeak</a> 安装与使用。</p><span id="more"></span><!-- toc --><h4 id="Hexo主题Tranquilpeak的安装与使用"><a href="#Hexo主题Tranquilpeak的安装与使用" class="headerlink" title="Hexo主题Tranquilpeak的安装与使用"></a>Hexo主题Tranquilpeak的安装与使用</h4><h5 id="Tranquilpeak下载并应用"><a href="#Tranquilpeak下载并应用" class="headerlink" title="Tranquilpeak下载并应用"></a>Tranquilpeak下载并应用</h5><p>需要安装Git工具 <code>yum install -y git</code></p><p>Hexo作为一个开源的博客框架自然对主题风格方面没有第三方限制，在完成<code>hexo init</code>初始化后目录列表中有一个<code>themes</code>的目录这个目录就是用来存放主题的，进入这个目录使用<code>git clone https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak.git</code>命令你会下载一个hexo-theme-tranquilpeak的文件目录为了方便起见,更改名称为tranquilpeak</p><p>进入到tranquilpeak目录下执行<code>npm install</code>下载主题所需相关依赖，下载完成后执行<code>npm run prod</code>构建主题.至此主题安装成功。</p><p>最后进入博客根目录下_config.yml配置文件<code>theme: </code>属性修改为 <code>theme: tranquilpeak</code>执行到这一步.主题已经下载且切换成功了。</p><p>Tranquilpeak看起来比较简单清爽，所以选择了这个主题.如果你觉得不符合你的风格，你也可以在Github搜索hexo theme或者通过官网找到你自己喜欢的一个风格。</p><h5 id="Tranquilpeak个人简介工作介绍-语言切换"><a href="#Tranquilpeak个人简介工作介绍-语言切换" class="headerlink" title="Tranquilpeak个人简介工作介绍/语言切换"></a>Tranquilpeak个人简介工作介绍/语言切换</h5><p>在~/博客根目录/themes/tranquilpeak/languages目录下有多种语言配置项，可以找到 <code>zh-cn.yml</code>文件这个文件是中文映射表,在这个文件可以修改你的个人简介和工作属性如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">author:</span><br><span class="line">    # 你的个人简介 (支持 Markdown 和 HTML 语法)</span><br><span class="line">    bio: </span><br><span class="line">    # 你的工作简介</span><br><span class="line">    job: &quot; &quot;</span><br></pre></td></tr></table></figure><p>修改语言回到博客根目录下修改_config.yml配置文件的<code>language:</code> 属性修改为<code>language: zh-cn</code></p><h5 id="Tranquilpeak头像-背景-网页icon修改"><a href="#Tranquilpeak头像-背景-网页icon修改" class="headerlink" title="Tranquilpeak头像/背景/网页icon修改"></a>Tranquilpeak头像/背景/网页icon修改</h5><p>在主题根目录tranquilpeak下有_config.yml配置文件，会找到<code>picture: picture.png</code>进入tranquilpeak/source/_images会看到picture.png图片文件，将你期望更换的头像拖入其中替换名称即可。更换图片后 进入到tranquilpeak目录下执行<code>npm run prod</code>命令重新部署使其资源修改。</p><p>同理</p><p>网页背景图属性<code>cover_image: cover.jpg</code></p><p>网页的icon属性<code>favicon: </code></p><h5 id="Tranquilpeak移除多余的功能键"><a href="#Tranquilpeak移除多余的功能键" class="headerlink" title="Tranquilpeak移除多余的功能键"></a>Tranquilpeak移除多余的功能键</h5><p>在主题根目录tranquilpeak下有_config.yml配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sidebar:</span><br><span class="line">    menu:</span><br><span class="line">    author_links:</span><br></pre></td></tr></table></figure><p>选择注释掉不需要的菜单，或者按照它的格式添加自定义的菜单都可以。</p><p>甚至于可以更改tranquilpeak中的ejs模板来生成出想要的菜单。</p><h5 id="启用RSS订阅功能"><a href="#启用RSS订阅功能" class="headerlink" title="启用RSS订阅功能"></a>启用RSS订阅功能</h5><p>项目根目录执行：<br><code>npm install hexo-generator-feed --save</code><br>在根目录的config中添加如下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">feed:</span><br><span class="line">    type: atom</span><br><span class="line">    path: atom.xml</span><br><span class="line">    limit: 20</span><br></pre></td></tr></table></figure><h5 id="启用侧边栏的”分类”菜单"><a href="#启用侧边栏的”分类”菜单" class="headerlink" title="启用侧边栏的”分类”菜单"></a>启用侧边栏的”分类”菜单</h5><p>博客根目录下执行<code>hexo new page “categories”</code></p><p>替换根目录的source/all-tags/index.md中的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: &quot;all-categories&quot;</span><br><span class="line">layout: &quot;all-categories&quot;</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure><h5 id="启用侧边栏的”标签”菜单"><a href="#启用侧边栏的”标签”菜单" class="headerlink" title="启用侧边栏的”标签”菜单"></a>启用侧边栏的”标签”菜单</h5><p>博客根目录下执行<code>hexo new page “tags”</code></p><p>替换根目录的source/all-tags/index.md中的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: &quot;all-tags&quot;</span><br><span class="line">layout: &quot;all-tags&quot;</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure><h5 id="启用侧边栏的”归档”菜单"><a href="#启用侧边栏的”归档”菜单" class="headerlink" title="启用侧边栏的”归档”菜单"></a>启用侧边栏的”归档”菜单</h5><p>博客根目录下执行<code>hexo new page “archives”</code></p><p>替换根目录的source/all-tags/index.md中的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: &quot;all-archives&quot;</span><br><span class="line">layout: &quot;all-archives&quot;</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure><h5 id="启用Gitalk评论功能"><a href="#启用Gitalk评论功能" class="headerlink" title="启用Gitalk评论功能"></a>启用<a href="https://github.com/gitalk/gitalk">Gitalk</a>评论功能</h5><p><a href="https://github.com/gitalk/gitalk">Gitalk</a>评论插件Tranquilpeak主题有预留功能只需要在主题目录下_config.yml文件中将其gitalk属性填写完成并启用，需要填写的内容在Gittalk文档中可以查看到对应的数属性字段.。</p><p><img src="https://i.loli.net/2021/05/05/bvmqMykWUanu2d7.png" alt="image-20210505204509436"></p><p>后期补充: 如果Gitalk评论出现403的问题，解决方案<a href="https://mp.weixin.qq.com/s?__biz=Mzg3MjU3NzU1OA==&mid=2247496606&idx=1&sn=8e0b6e2600f939c5401f2344dce2cba6&source=41#wechat_redirect">记录一次 Bug 排查过程并分享一些经验</a>里面给出了问题原因和解决方案。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak&quot;&gt;Tranquilpeak&lt;/a&gt; 安装与使用。&lt;/p&gt;</summary>
    
    
    
    <category term="博客" scheme="https://blog.methodref.top/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="博客相关" scheme="https://blog.methodref.top/tags/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>博客的搭建</title>
    <link href="https://blog.methodref.top/2020/09/17/2.%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%BB%BA%E7%AB%8B/"/>
    <id>https://blog.methodref.top/2020/09/17/2.%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%BB%BA%E7%AB%8B/</id>
    <published>2020-09-16T16:00:00.000Z</published>
    <updated>2021-06-03T03:26:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>博客的建立记录。</p><span id="more"></span><!-- toc --><h4 id="搭建方式的选择"><a href="#搭建方式的选择" class="headerlink" title="搭建方式的选择"></a>搭建方式的选择</h4><p> ​开始准备搭建博客的时候，初步的了解了下搭建个人博客几种方式：</p><ol><li>自行开发一个简单的博客平台，自己写前后端代码，开发完成后部署到一台服务器上。</li><li><a href="https://hexo.io/">Hexo</a>(基于js)，配置好后一键生成静态页面，使用起来比较简单，部署也比较方便，可以部署到Github提供的<a href="https://pages.github.com/">GitPages</a>免费服务器，也可以自行购入服务器进行部署。</li><li><a href="https://jekyllrb.com/">Jekyll</a>(基于RubyGems)，支持生成静态页面，部署的方式和Hexo一致。</li><li><a href="https://www.gohugo.org/">Hugo</a>(基于GO)，支持生成静态页面，部署的方式和Hexo一致。</li><li><a href="https://b3log.org/solo/">Solo</a>(基于Java)，支持生成静态页面，部署的方式和Hexo一致。</li></ol><p>经过对比最终选择了Hexo因为它是一款开源的博客框架，且使用的人数比较多，出现问题比较容易找到对应的解决方案。最重要的是简单易用。</p><h4 id="基于Hexo简单搭建步骤"><a href="#基于Hexo简单搭建步骤" class="headerlink" title="基于Hexo简单搭建步骤"></a>基于Hexo简单搭建步骤</h4><p>方便起见建议使用Liux系统进行安装操作，你可以使用虚拟机的形式安装一个Liux系统或者采用Docker容器的方式安装Linux系统。</p><ol><li><p>使用yum安装Node.js 版本安装稳定版即可.windows系统建议使用官网下载安装包的方式进行安装.macos建议使用brew进行安装.<br>安装完成后使用<code>node -v</code>命令查看node.js版本再使用<code>npm -v</code>查看包管理器版本确定是否安装成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nodejs12</span><br></pre></td></tr></table></figure></li><li><p>使用Node.js的包管理工具npm全局的形式安装hexo. 使用<code>hexo -v</code>查看hexo版本确定是否安装成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure></li><li><p>安装hexo成功后cd进入当前用户目录下创建一个文件夹进入文件夹后使用hexo命令来初始化这个文件夹使其成为hexo的项目结构，~博客根目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure></li><li><p>至此一个博客框架的雏形便搭建完成了，接下来需要做的就是去看<a href="https://hexo.io/zh-cn/docs/commands">Hexo的官网文档</a>熟悉Hexo的操作命令部署指南即可。<br>常用命令如下</p><ul><li><code>hexo s</code>启动hexo服务</li><li><code>hexo g</code> generate生成静态页面</li><li><code>hexo clean</code> 删除生成的静态页面</li><li><code>hexo new &#39;newBlogName&#39;</code> 生成新的博客页面</li><li><code>hexo d</code> 以博客根目录下_config.yml中deploy配置的部署方式进行部署</li></ul><p>博客根目录下_config.yml是你博客的主要配置信息常用的配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">title: 标题</span><br><span class="line">author: 作者</span><br><span class="line">language: 语言&lt;一般使用主题包中提供的语言信息&gt;</span><br><span class="line">url: 博客根访问路径作为一个环境变量</span><br><span class="line">theme: 选择的主题名称</span><br><span class="line">plugins:</span><br><span class="line">  - 插件名称 &lt;-格式表示是一个数组形式的属性&gt;</span><br><span class="line">deploy: </span><br><span class="line">deploy:</span><br><span class="line">  type: 部署方式</span><br><span class="line">  repo: 部署路径</span><br></pre></td></tr></table></figure></li></ol><h4 id="Hexo简单的部署"><a href="#Hexo简单的部署" class="headerlink" title="Hexo简单的部署"></a>Hexo简单的部署</h4><p>使用<code>hexo g</code> 命令生成静态页面，你会在博客根目录下看到生成了一个<code>public</code>文件夹.文件夹内存储的就是博客的静态页面.你可以使用这个简单的静态页面部署至你购买服务器的web容器中去.常见的有Tomcat Jboss Nginx.配置好环境变量后就可以进行访问。</p><p>本质上来说Hexo博客框架的作用，就是把你所写的Markdown格式的博客，以静态页面的形式生成出来。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;博客的建立记录。&lt;/p&gt;</summary>
    
    
    
    <category term="博客" scheme="https://blog.methodref.top/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="博客相关" scheme="https://blog.methodref.top/tags/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>博客伊始</title>
    <link href="https://blog.methodref.top/2020/09/14/1.%E5%8D%9A%E5%AE%A2%E4%BC%8A%E5%A7%8B/"/>
    <id>https://blog.methodref.top/2020/09/14/1.%E5%8D%9A%E5%AE%A2%E4%BC%8A%E5%A7%8B/</id>
    <published>2020-09-13T16:00:00.000Z</published>
    <updated>2021-06-03T03:26:58.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h5 id="建立博客的动机"><a href="#建立博客的动机" class="headerlink" title="建立博客的动机"></a>建立博客的动机</h5><p>​    初次使用到博客是在网上搜索资料解决问题时遇到的CSDN博客论坛，在解决问题后不由得对这个论坛上博客作者心生感激。</p><p>​    后续接触到了<a href="http://www.ruanyifeng.com/blog/">阮一峰的网络日志</a>、<a href="https://tumutanzi.com/">土木坛子</a>、<a href="http://www.yinwang.org/#">当然我在扯淡</a>、<a href="https://blog.dandyweng.com/">翁天信的博客</a> 等优秀的个人博客，极大的扩宽了视野，进而产生了建立个人博客的想法。</p><p>​    再后来发现自己的浏览器收藏夹中大量的收藏知识和资料的链接都变成了404，而其中的很多资料都是打算保存下来后面有时间再去处理的资料，但是一直没有去处理的资料，这个事情已经影响到了我，于是建立博客的事情便提上了日程。</p><h5 id="建立博客目的"><a href="#建立博客目的" class="headerlink" title="建立博客目的"></a>建立博客目的</h5><p>​    给自己一个处理资料的动力。<br>​    一个属于自己的收藏夹。</p><h5 id="博客的内容"><a href="#博客的内容" class="headerlink" title="博客的内容"></a>博客的内容</h5><p>​    <a href="https://baike.baidu.com/item/%E5%8D%9A%E5%AE%A2/124">博客</a>最初的名称是<a href="https://baike.baidu.com/item/Weblog">Weblog</a>，由web和log两个单词组成，按字面意思就为网络日记，后来喜欢新名词的人把这个词的发音故意改了一下，读成we blog，由此，blog这个词被创造出来。中文意思即网志或**<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%97%A5%E5%BF%97">网络日志</a><strong>，不过，在中国大陆有人往往也将</strong>Blog<strong>本身和</strong><a href="https://baike.baidu.com/item/blogger">blogger</a>**（即博客作者）均音译为“博客”。“博客”有较深的涵义：“博”为“广博”；“客”不单是“blogger”更有“好客”之意。看Blog的人都是“客”。而在台湾，则分别音译成“部落格”（或“部落阁”）及“部落客”，认为Blog本身有社群群组的意含在内，借由Blog可以将网络上网友集结成一个大博客，成为另一个具有影响力的自由媒体。</p><p>​    ① blog = Web log = 部落格 =网络日志=网志=网络日记本<br>​    ② blogger = 写blog的人=博主</p><p>博客的定义我觉得最好的一句话是<code>博客永远是共享与分享精神的体现</code><br>这个博客书写的内容更像是个人收藏夹，收藏一些日常遇到的各种各样问题与见识。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;为什么要建立博客和博客的内容。&lt;/p&gt;</summary>
    
    
    
    <category term="博客" scheme="https://blog.methodref.top/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="博客相关" scheme="https://blog.methodref.top/tags/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>template</title>
    <link href="https://blog.methodref.top/2020/05/02/template/"/>
    <id>https://blog.methodref.top/2020/05/02/template/</id>
    <published>2020-05-02T08:49:27.000Z</published>
    <updated>2021-05-12T09:27:55.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><p><code>&lt;!-- more --&gt;</code></p><span id="more"></span><p><code>&lt;!-- toc --&gt;</code></p><!-- toc --><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="figure left" style="width:85%;"><a class="fancybox" href="https://i.loli.net/2021/05/05/HlyQfdkGYBRhD7u.jpg" title="" data-caption="" data-fancybox="travel"><img class="fig-img" src="https://i.loli.net/2021/05/05/HlyQfdkGYBRhD7u.jpg" style="width:85%;height:82%;"alt=""></a></div><div style="clear:both;"></div><p>你应该不知道这个的内容</p><h2 id="文章结束"><a href="#文章结束" class="headerlink" title="文章结束"></a>文章结束</h2><p>————————————————</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;&amp;lt;!-- excerpt --&amp;gt;&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
